-- @atlcompiler atl2010

-- @nsURI UML=http://www.eclipse.org/uml2/4.0.0/UML
-- @nsURI JAVA=http://www.eclipse.org/MoDisco/Java/0.2.incubation/java

-- ******************************************************************************
-- Copyright (c) 2013 INRIA. 
-- All rights reserved. This program and the accompanying materials 
-- are made available under the terms of the Eclipse Public License v1.0 
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
-- 
-- Contributors: 
-- 	INRIA - Initial implementation
--  authors: Guillaume Doux (guillaume.doux at inria.fr) 
--			 Matthieu Allon (matthieu.allon at gmail.com)
-- Initially developed in the context of ARTIST EU project www.artist-project.eu
-- ******************************************************************************

module JavaMethods2UMLActivityDiagram;

create OUT: UML from IN: JAVA;

uses java2UMLActivityHelpers;

rule JModelRootToUmlModelRoot {
	from 
		jModelRoot : JAVA!Model(
			jModelRoot.notInClassInstanceCreation --MODIF	
		)
	to 
		umlModelRoot : UML!Model (
			name <- 'root model',			
			packagedElement <- jModelRoot.allAbstractMethodDeclaration
								->including(cd)
								-> append(thisModule.createExternalsModel(jModelRoot))	
		),
		cd	:	UML!Package(
			name <- 'Associated Classifiers',
			packagedElement <- thisModule.allTypes 
									-> union(UML!Dependency.allInstancesFrom('OUT'))
		)
}

---Create 'external' model
unique lazy rule createExternalsModel{
	from 
		jModel : JAVA!Model(
			jModel.notInClassInstanceCreation --MODIF	
		)
	to 
		umlModel : UML!Package(
			name <- 'externals',
			packagedElement <- jModel.getExternalElements
								-> select(elem | elem.oclIsTypeOf(JAVA!Package))
								-> select(elem | elem.isAnExternalPackage)
		)
}

---Package only for the external lib.
rule JPackageToUmlPackage {
	from 
		jPackage : JAVA!Package(
			jPackage.isAnExternalPackage
			and jPackage.notInClassInstanceCreation --MODIF
		)
	to 
		umlPackage : UML!Package (
				name <- jPackage.name, 
				nestedPackage <- jPackage.ownedPackages 
									-> select(elem | elem.isAnExternalPackage),
				packagedElement <- jPackage.ownedElements 
										-> select(c | c.oclIsKindOf(JAVA!ClassDeclaration) 
														or c.oclIsKindOf(JAVA!InterfaceDeclaration) 
														or c.oclIsKindOf(JAVA!EnumDeclaration)
										)
										->collect(c | if c.originalCompilationUnit.oclIsUndefined() 
														then OclUndefined
														else c.originalCompilationUnit.imports
													endif )->flatten()
										->union(
											jPackage.ownedElements	
										),
				nestingPackage <- if (not jPackage.getPackage.oclIsUndefined())then
								 	if (jPackage.getPackage.isAnExternalPackage)then
										jPackage.getPackage
								  	else OclUndefined endif	
								  else OclUndefined endif		
		)
		
}

rule createDependency{
	from 
		jImportDec : JAVA!ImportDeclaration(
			jImportDec.notInClassInstanceCreation --MODIF	
		)
	to 
		umlDependency : UML!Dependency (		
			name <- jImportDec.importedElement.name + '_OF_' + jImportDec.refImmediateComposite().name
--MODIF
--			supplier <- if jImportDec.importedElement.oclIsKindOf(JAVA!VariableDeclarationFragment) then 
--							jImportDec.importedElement.originalCompilationUnit.types
--						else 
--							if jImportDec.importedElement.oclIsKindOf(JAVA!AnnotationTypeDeclaration) then
--								jImportDec.importedElement.usagesInImports
--									-> collect(usImport | usImport.originalCompilationUnit.types)	
--							else 
--								if (jImportDec.importedElement.oclIsKindOf(JAVA!EnumConstantDeclaration))then
--									jImportDec.importedElement.refImmediateComposite()
--								else jImportDec.importedElement endif
--							endif
--						endif
		)
	do{
		--'isVariableDeclarationFragment: '.concat(jImportDec.importedElement.oclIsKindOf(JAVA!VariableDeclarationFragment).toString()).println();
		--'isAnnotationTypeDeclaration: '.concat(jImportDec.importedElement.oclIsKindOf(JAVA!AnnotationTypeDeclaration).toString()).println();
		--'isEnumConstantDeclaration: '.concat(jImportDec.importedElement.oclIsKindOf(JAVA!EnumConstantDeclaration).toString()).println();
	}
}

abstract rule abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block(
			block.getReturnStateGeneratingSAN
			and block.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			node <- Sequence{init, block.statements -> select(state | not state.isReturnStateGeneratingObjectFlow), final} -> flatten()
		),
		
		init	:	UML!InitialNode(),
		final	:	UML!ActivityFinalNode(),
		fcf : UML!ControlFlow(
			name <- 'fromInitLastStatementToFinalNode',
			inStructuredNode <- t,
			target <- final,
			source <- 	if (not block.getReturnStateGeneratingSAN) then
							init
						else 
							block.statements.last().getSourceTargetOrOwnerSAN
						endif,
			guard <- gu, --MODIF
			weight <- we --MODIF
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
}

rule Block2StructuredActivity extends abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block	((not block.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration)) 
									and block.notInInitializerOrFieldOrEnum
								 	and block.notInAnnotation
									and not block.hasOnlyReturnInstanceCreateNoParam
									and block.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Block - ' + block.refImmediateComposite().oclType().toString(),
			inStructuredNode <- block.refImmediateComposite()
		)
	do{
		
			
	}
}
--original
--rule Block2StructuredActivityForM extends abstractBlock2StructuredActivity{
--	from
--		block	:	JAVA!Block	(block.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration) 
--									and	block.notInAnnotation			
--									and not block.hasOnlyReturnInstanceCreateNoParam
--		)
--	to
--		t	:	UML!StructuredActivityNode(
--			name <- 'structured_'+block.refImmediateComposite(),
--			activity <- block.getOwningMethod--getOwningMethod returns MethodDeclaration, activity:Activity
--		)
--}
--MODIF
rule Block2StructuredActivityForM extends abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block	(block.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration) 
									and	block.notInAnnotation			
									and not block.hasOnlyReturnInstanceCreateNoParam
									and block.notInClassInstanceCreation --MODIF
									and block.notInEnumDeclaration --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'structured_'+block.refImmediateComposite(),
			activity <- block.getOwningMethod--getOwningMethod returns MethodDeclaration, activity:Activity
		)
	do{
--		if(block.refImmediateComposite().oclIsTypeOf(JAVA!MethodDeclaration)){
--			'MethodDeclaration name2: '.concat(block.refImmediateComposite().name).println();
--		}
	}
}
---(Anonymous)Class
abstract rule abstratASTNodeToClass{
	from
		s : JAVA!ASTNode (
			s.notInClassInstanceCreation --MODIF	
		)
	to
		t : UML!Classifier(
			ownedOperation <- s.bodyDeclarations 
								-> select(d | d.oclIsTypeOf(JAVA!MethodDeclaration))
								-> collect(d | thisModule.resolveTemp(d, 'operation'))
		)
}

rule AnonymousClass extends abstratASTNodeToClass {
	from
		s	:	JAVA!AnonymousClassDeclaration(
				s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!Class(
			name <- if (not s.refImmediateComposite().oclIsKindOf(JAVA!EnumConstantDeclaration)) then
						s.classInstanceCreation.type.type.name
					else 'EnumConstant_' + s.refImmediateComposite().name endif,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)		
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);
	}	
}

rule Class extends abstratASTNodeToClass {
	from
		s	:	JAVA!ClassDeclaration(
			s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!Class(
			name <- s.name,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)		
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule enumDeclaration extends abstratASTNodeToClass {
	from
		s	:	JAVA!EnumDeclaration(
			s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported',
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);
	}	
}

rule JInterfaceToUmlInterface extends abstratASTNodeToClass {
	from 
		s : JAVA!InterfaceDeclaration(
			s.notInClassInstanceCreation --MODIF	
		)
	to 
		t : UML!Interface (
			name <- s.name,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);
	}		
}

---All statements
abstract rule abstractExpressStatement{
	from
		s : JAVA!Statement(
			s.notInInitializerOrFieldOrEnum
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			incoming <- controlFlow
		),
		
		controlFlow: UML!ControlFlow(
			name <- 'fromPreviousStructuredActivityNode',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		
		initialNode : UML!InitialNode(
			inStructuredNode <- t
		),	
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToFirstStructuredActivityNode',
			inStructuredNode <- t,
			source <- initialNode,
			target <- 	if (s.getPreceding().getSourceTargetOrOwnerSAN.oclIsUndefined())then
							initialNode
						else s.getPreceding().getSourceTargetOrOwnerSAN endif,
			guard <- gu2,
			weight <- we2
		),			
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		finalControlFlow: UML!ControlFlow(
			name <- 'fromLastStructuredActivityNodeToFinalNode',
			inStructuredNode <- t,
			source <- s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- final,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

abstract rule abstractSpecificExpressStatement{
	from
		s : JAVA!Statement(
			s.notInInitializerOrFieldOrEnum
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		initialNode : UML!InitialNode(
			inStructuredNode <- t
		),	
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToFirstStructuredActivityNode',
			inStructuredNode <- t,
			source <- initialNode,
			target <- 	if (s.getPreceding().getSourceTargetOrOwnerSAN.oclIsUndefined())then
							initialNode
						else s.getPreceding().getSourceTargetOrOwnerSAN endif,
			guard <- gu,
			weight <- we
		),			
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		finalControlFlow: UML!ControlFlow(
			name <- 'fromLastStructuredActivityNodeToFinalNode',
			inStructuredNode <- t,
			source <- s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- final,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule instanceVariableUseNotSettNullExpressState extends abstractExpressStatement{
	from
		s : JAVA!ExpressionStatement(
			s.isInstanceVarUse
			and not s.isImplicitThisExpression
			and not s.isSettingNull
			and not s.isClearingList
			and not s.isAddingInList
			and not s.isRemovingInList
			and s.notInClassInstanceCreation --MODIF
		)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'Instance variable use'
		),		
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <-	s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec 
									else OclUndefined endif	
								  else OclUndefined endif,	
			result <- op
		),	
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- 	if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							) 
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
						
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule instanceVariableUseSettNullExpressState extends abstractExpressStatement{
	from
		s : JAVA!ExpressionStatement(
			s.isInstanceVarUse
			and not s.isImplicitThisExpression
			and s.isSettingNull
			and s.notInClassInstanceCreation --MODIF
		)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'Instance variable use - set null'
		),		
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToClearStructuralFeatureActionInitNode',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- initialNodeCFA,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),		
		up	:	UML!LiteralInteger(
			value <- 1
		),
		initialNodeCFA : UML!InitialNode(),	
		initialControlFlow : UML!ControlFlow(
			name <- 'fromInitNodeToClearStructuralFeatureActionInit',
			inStructuredNode <- t,
			source <- initialNodeCFA,
			target <- clearStructuralFeature,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		inputCFA : UML!InputPin (
			name <- 'clearStructuralFeatureActionInput',
			incoming <- initialControlFlow,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- initialControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
											express.getFieldDec
									else OclUndefined endif										
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutput')		
		),
		finalControlFlow : UML!ControlFlow(
			name <- 'fromClearStructuralFeatureActionToFinalNode',
			inStructuredNode <- t,
			source <- clearStructuralFeature,
			target <- final,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode()
}

rule implicitThis2IntanceVarUsereadSelf extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.isImplicitThisExpression
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Implicit this'
		),		
		
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec	
									else OclUndefined endif	
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- 	if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule expressionStatement extends abstractSpecificExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and not s.isClearingList			
			and not s.isAddingInList
			and not s.isRemovingInList
			and s.notInClassInstanceCreation --MODIF
			and s.notInEnumDeclaration --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Not Implicit this, no method used, and no collection used',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		fcf : UML!ControlFlow(
			name <- 'fromInitialNodeToInitLastStatement',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,--returns self, inStructureNode: StructuredActivityNode
			source <- thisModule.resolveTemp(s.refImmediateComposite().getSourceTargetOrOwnerSAN, 'init'),
			target <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		)
}


---Clearing list
rule expressionStatementClearListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isClearingList			
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - method used'		
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		--Getter used
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,		
			result <- op
		),	
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <-  s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),		
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		inputCFA : UML!InputPin (
			name <- 'clearStructuralFeatureActionInputPin',
			incoming <- outControlFlow,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		--Clear coll.
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- outControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
											s.express.getFieldDec									
									else OclUndefined endif	
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutputPin')		
		)
}

rule expressionStatementClearListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - This, method used'
		),
				
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		--Clear coll.
		inputCFA : UML!InputPin (
			name <- 'fromOutControlFlowToClearStructuralFeatureAction',
			incoming <- outControlFlow,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- outControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
										s.express.getFieldDec
									else OclUndefined endif	
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutput')		
		)
}

rule expressionStatementClearListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - Implicit this, no method used'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputCFA,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputCFA : UML!InputPin (
			name <- 'objectInput',
			incoming <- objectflow,
			upperBound <- li
		),	
		li	:	UML!LiteralInteger(
			value <- 1
		),
		--Clear coll.
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- initialControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
										s.express.getFieldDec	
									else OclUndefined endif	
								else OclUndefined endif,
			result <- op			
		),		
		op	:	UML!OutputPin (
			name <- 'clearStructuralFeatureActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		fcf : UML!ControlFlow(
			name <- 'fromInitialNodeToInitLastStatement',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.getStatement.getSourceTargetOrOwnerSAN, 'init'),
			target <- s.getSourceTargetOrOwnerSAN,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		)
}

rule expressionStatementClearList extends abstractSpecificExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - No method used'
		),
		
		fcf : UML!ControlFlow(
			name <- 'fromInitialNodeToInitLastStatement',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.getStatement.getSourceTargetOrOwnerSAN, 'init'),
			target <- s.getSourceTargetOrOwnerSAN,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		)
}

---Addition of an element in a list
rule expressionStatementAddListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isAddingInList			
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - Method used'		
		),
				
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),		
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',	
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- op,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput,
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <-s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif,
			upperBound <- li4
		),
		li4	:	UML!LiteralInteger(
			value <- 1
		)
}

rule expressionStatementAddListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - This, Method invocation'
		),
				
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),		
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',	
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- op,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput,
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- 	if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif,
			upperBound <- li4
		),
		li4	:	UML!LiteralInteger(
			value <- 1
		)
}

rule expressionStatementAddListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - Implicit this, no Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif,
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		)
}

rule expressionStatementAddList extends abstractSpecificExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - no Method invocation'
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- objectIP,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif,
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		)
}

---Removing an element in a collection
rule expressionStatementRemoveListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isRemovingInList		
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - Method used'		
		),
				
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureAction',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,	
			result <- op
		),		
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							) 
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),		
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- op,
			target <- forkNode,
			inStructuredNode <- t,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'controlOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t,
			guard <- gu8,
			weight <- we8
		),
		gu8	:	UML!LiteralBoolean(
			value <- false
		),
		we8	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF,
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		),
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin('readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t,
			guard <- gu9,
			weight <- we9
		),
		gu9	:	UML!LiteralBoolean(
			value <- false
		),
		we9	:	UML!LiteralBoolean(
			value <- false
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior',
			upperBound <- li4
		),
		li4	:	UML!LiteralInteger(
			value <- 1
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu10,
			weight <- we10
		),
		gu10	:	UML!LiteralBoolean(
			value <- false
		),
		we10	:	UML!LiteralBoolean(
			value <- false
		),
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},			
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t,
			guard <- gu11,
			weight <- we11
		),
		gu11	:	UML!LiteralBoolean(
			value <- false
		),
		we11	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction',
			upperBound <- li5
		),
		li5	:	UML!LiteralInteger(
			value <- 1
		),
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.getRemoveCollectionArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,						
			target <- forkNodeIndex,
			inStructuredNode <- t,
			guard <- gu12,
			weight <- we12
		),
		gu12	:	UML!LiteralBoolean(
			value <- false
		),
		we12	:	UML!LiteralBoolean(
			value <- false
		),
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu13,
			weight <- we13
		),
		gu13	:	UML!LiteralBoolean(
			value <- false
		),
		we13	:	UML!LiteralBoolean(
			value <- false
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1,
			upperBound <- li6
		),
		li6	:	UML!LiteralInteger(
			value <- 1
		),
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t,
			guard <- gu14,
			weight <- we14
		),
		gu14	:	UML!LiteralBoolean(
			value <- false
		),
		we14	:	UML!LiteralBoolean(
			value <- false
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1,
			upperBound <- li7
		),
		li7	:	UML!LiteralInteger(
			value <- 1
		)
}

rule expressionStatementRemoveListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - This, Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureAction',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow,
			upperBound <- li
		),		
		li	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <- 'read',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,	
			result <- op
		),		
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu5,
			weight <- we5
		),		
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- op,
			target <- forkNode,
			inStructuredNode <- t,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t,
			guard <- gu8,
			weight <- we8
		),
		gu8	:	UML!LiteralBoolean(
			value <- false
		),
		we8	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF,
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		),
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t,
			guard <- gu9,
			weight <- we9
		),
		gu9	:	UML!LiteralBoolean(
			value <- false
		),
		we9	:	UML!LiteralBoolean(
			value <- false
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior',
			upperBound <- li4
		),
		li4	:	UML!LiteralInteger(
			value <- 1
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu10,
			weight <- we10
		),
		gu10	:	UML!LiteralBoolean(
			value <- false
		),
		we10	:	UML!LiteralBoolean(
			value <- false
		),
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t,
			guard <- gu11,
			weight <- we11
		),
		gu11	:	UML!LiteralBoolean(
			value <- false
		),
		we11	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction',
			upperBound <- li5
		),
		li5	:	UML!LiteralInteger(
			value <- 1
		),
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.getRemoveCollectionArgument.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,					
			target <- forkNodeIndex,
			inStructuredNode <- t,
			guard <- gu12,
			weight <- we12
		),
		gu12	:	UML!LiteralBoolean(
			value <- false
		),
		we12	:	UML!LiteralBoolean(
			value <- false
		),
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu13,
			weight <- we13
		),
		gu13	:	UML!LiteralBoolean(
			value <- false
		),
		we13	:	UML!LiteralBoolean(
			value <- false
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1,
			upperBound <- li6
		),
		li6	:	UML!LiteralInteger(
			value <- 1
		),
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t,
			guard <- gu14,
			weight <- we14
		),
		gu14	:	UML!LiteralBoolean(
			value <- false
		),
		we14	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'controlOutput',
			outgoing <- outControlFlow,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
--		uvf	:	UML!LiteralBoolean(
--			value <- false
--		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1,
			upperBound <- li7
		),
		li7	:	UML!LiteralInteger(
			value <- 1
		)
}

rule expressionStatementRemoveListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - Implicit this, no Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- forkNode,
			inStructuredNode <- t,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior',
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu8,
			weight <- we8
		),
		gu8	:	UML!LiteralBoolean(
			value <- false
		),
		we8	:	UML!LiteralBoolean(
			value <- false
		),
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t,
			guard <- gu9,
			weight <- we9
		),
		gu9	:	UML!LiteralBoolean(
			value <- false
		),
		we9	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction',
			upperBound <- li4
		),
		li4	:	UML!LiteralInteger(
			value <- 1
		),
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,
			target <- forkNodeIndex,
			inStructuredNode <- t,
			guard <- gu10,
			weight <- we10
		),
		gu10	:	UML!LiteralBoolean(
			value <- false
		),
		we10	:	UML!LiteralBoolean(
			value <- false
		),
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu11,
			weight <- we11
		),
		gu11	:	UML!LiteralBoolean(
			value <- false
		),
		we11	:	UML!LiteralBoolean(
			value <- false
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1,
			upperBound <- li5
		),
		li5	:	UML!LiteralInteger(
			value <- 1
		),
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t,
			guard <- gu12,
			weight <- we12
		),
		gu12	:	UML!LiteralBoolean(
			value <- false
		),
		we12	:	UML!LiteralBoolean(
			value <- false
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1,
			upperBound <- li6
		),
		li6	:	UML!LiteralInteger(
			value <- 1
		)
}

rule expressionStatementRemoveList extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - no Method invocation'
		),
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- forkNode,
			inStructuredNode <- t,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNode,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNode,
			target <- inPinReadSF,
			inStructuredNode <- t,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		readSF : UML!ReadStructuralFeatureAction(
			name <- 'read',
			object <- inPinReadSF,			
			result <- op,
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- op,
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'ReadStructuralFeatureActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior',
			upperBound <- li6
		),
		li6	:	UML!LiteralInteger(
			value <- 1
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu8,
			weight <- we8
		),
		gu8	:	UML!LiteralBoolean(
			value <- false
		),
		we8	:	UML!LiteralBoolean(
			value <- false
		),
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s,'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t,
			guard <- gu9,
			weight <- we9
		),
		gu9	:	UML!LiteralBoolean(
			value <- false
		),
		we9	:	UML!LiteralBoolean(
			value <- false
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction',
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		),
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.getRemoveCollectionArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,
			target <- forkNodeIndex,
			inStructuredNode <- t,
			guard <- gu10,
			weight <- we10
		),
		gu10	:	UML!LiteralBoolean(
			value <- false
		),
		we10	:	UML!LiteralBoolean(
			value <- false
		),
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t,
			guard <- gu11,
			weight <- we11
		),
		gu11	:	UML!LiteralBoolean(
			value <- false
		),
		we11	:	UML!LiteralBoolean(
			value <- false
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1,
			upperBound <- li4
		),
		li4	:	UML!LiteralInteger(
			value <- 1
		),
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t,
			guard <- gu12,
			weight <- we12
		),
		gu12	:	UML!LiteralBoolean(
			value <- false
		),
		we12	:	UML!LiteralBoolean(
			value <- false
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1,
			upperBound <- li5
		),
		li5	:	UML!LiteralInteger(
			value <- 1
		)
}

abstract rule returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement(
				s.notInClassInstanceCreation --MODIF
				and s.notInEnumDeclaration --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- s.getOwningMethod.name +' return'
		),
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode',
			activity <- s.getOwningMethod,
			--MODIF
			--source <- s.getSourceForObjectFlow(),
			source <- if (s.getSourceForObjectFlow().oclIsUndefined()) then 
							apn --source is filled to avoid error when validating UML
					  else 
					  		s.getSourceForObjectFlow() 
					  endif,
			target <- apn,
			guard <- gu,
			weight <- we --ValueSpecification
		),	
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
				
		apn	:	UML!ActivityParameterNode(
			name <- 'return',
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif,
			parameter <- paramAct,
			incoming <- ob,
			upperBound <- li--ValueSpecification
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		paramAct	:	UML!Parameter(
			name <- 'return',
			direction <- #return,
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif
					
		)
	
}	

rule returnStatementNoMethodCall extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.isReturnStateGeneratingObjectFlow
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- s.getOwningMethod.name +' return'
		),
		ob : UML!ObjectFlow( --MODIF
			name <- 'fromExpressionToActivityParameterNode 1.1'
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
		
	}	
}	

rule returnStatementConstructCall{
	from
		s	:	JAVA!ReturnStatement (
			s.isReturnStateGeneratingObjectFlow
			and s.notInClassInstanceCreation --MODIF
		)
	to
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode2', --MODIF
			activity <- s.getOwningMethod,
			source <- s.getSourceForObjectFlow(),
--			source <- if (thisModule.resolveTemp(s.expression, 'forkNode').oclIsUndefined())then
--							if (thisModule.resolveTemp(s.expression, 'op').oclIsUndefined())then
--								if (thisModule.resolveTemp(s.getVarDecStatement, 'forkNode').oclIsUndefined())then
--									if (s.expression.oclIsTypeOf(JAVA!SingleVariableAccess)) then 
--										thisModule.resolveTemp(s.expression.variable, 'apn')
--									else OclUndefined endif	
--								else thisModule.resolveTemp(s.getVarDecStatement, 'forkNode') endif
--							else thisModule.resolveTemp(s.expression, 'op') endif
--						else thisModule.resolveTemp(s.expression, 'forkNode') endif,
			target <- apn,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		apn	:	UML!ActivityParameterNode(
			name <- 'return',
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif,
			parameter <- paramAct,
			incoming <- ob,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		paramAct	:	UML!Parameter(
			name <- 'return',
			direction <- #return,
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif
					
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
		
	}	
}	

rule returnStatementNoMethodCallAndInstanceVarImplcitThis extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.expression.oclIsKindOf(JAVA!MethodInvocation)	
			and s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(),		
		obToReadStruct : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureActionInput',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
--						s.expression
						s.getSourceForObjectFlow()
					  else OclUndefined endif,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		--(Implicit)This
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		inputPin : UML!InputPin(
			name <- 'readInput',
			upperBound <- ub --MODIF
		),
		ub	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <-'read',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then --When return 'null', empty 'expression' reference
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,
			result <- op,
			incoming <- obToReadStruct
		),			
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
	    op : UML!OutputPin (
			name <- 'resultOutput',
			upperBound <- ub2 --MODIF
		),
		ub2	:	UML!LiteralInteger(
			value <- 1
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
		
	}	
}

rule returnStatementNoMethodCallAndInstanceVar extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.expression.oclIsKindOf(JAVA!MethodInvocation)	
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- s.getOwningMethod.name +' return'
		),
				
		obToReadStruct : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureActionInput2', --MODIF
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
--						s.expression
						s.getSourceForObjectFlow()
					  else OclUndefined endif,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		inputPin : UML!InputPin(
			name <- 'readInput',
			upperBound <- ub
		),
		ub	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <-'read',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then --When return 'null', empty 'expression' reference
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,
			result <- op,
			incoming <- obToReadStruct
		),			
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- readStruct,
			target <- if (not s.getOwningMethod.body.isReturnStateGeneratingObjectFlow)then
							s.getOwningMethod.body.statements
							-> select(state | state.oclIsKindOf(JAVA!ReturnStatement)
												and not state.isReturnStateGeneratingObjectFlow
							)
							-> first()
						else OclUndefined endif,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
	    op : UML!OutputPin (
			name <- 'resultOutput',
			upperBound <- ub2 --MODIF
		),
		ub2	:	UML!LiteralInteger(
			value <- 1
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
		
	}	
}	
		
rule returnStatementNoMethodCallAndImplicit extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
--			not s.expression.oclIsKindOf(JAVA!MethodInvocation)	--MODIF
--			and s.isImplicitThisExpression
--			and not s.isInstanceVarUse
			s.isReturnSimpleImplicitThis
			and s.notInClassInstanceCreation --MODIF
			and s.notInEnumDeclaration --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
				name <- s.getOwningMethod.name +' return'
		),
					
		ob : UML!ObjectFlow( --MODIF
			name <- 'fromExpressionToReadStructuralFeatureActionInput3', --MODIF
			inStructuredNode <- t
			
		),
		--(Implicit)This
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- t
		),
		
		inputPin : UML!InputPin(
			name <- 'readInput',
			upperBound <- ub
		),
		ub	:	UML!LiteralInteger(
			value <- 1
		),
		readStruct : UML!ReadStructuralFeatureAction(
			name <-'read',
			inStructuredNode <- t,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then --When return 'null', empty 'expression' reference
									if (not s.expression.getObject.oclIsUndefined())then
										s.expression.getObject.getFieldDec
									else OclUndefined endif	
								  else OclUndefined endif,
			result <- op,
			incoming <- ob --MODIF
		),		
	    op : UML!OutputPin (
			name <- 'resultOutput',
			upperBound <- ub2 --MODIF
		),
		ub2	:	UML!LiteralInteger(
			value <- 1
		)
		
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
		
	}	
}

rule returnStatementMethodInvocation extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			s.expression.oclIsKindOf(JAVA!MethodInvocation)	
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
				name <- s.getOwningMethod.name +' return'	
		),
		
		--Calling method
		inputPin	:	UML!InputPin (
			name <- 'targetInput',
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		of2CallOperAct : UML!ObjectFlow (
			name <- 'fromMethodInvocationOutPut',
			source <- thisModule.resolveTemp(s.expression.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		co	:	UML!CallOperationAction(
			name <- if (not s.expression.method.oclIsUndefined()) then
						 s.expression.method.name
					else 'Undefined' endif,
			operation <- thisModule.resolveTemp(s.expression.method, 'operation'),
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- s.expression.arguments->collect(a | 	if a.isPrimitiveType then
																	thisModule.createArgument(a)
																else
																	thisModule.createArgumentNotPrimitiv(a)
																endif	
			),
			result <- op,
			incoming <- of2CallOperAct,
			target <- inputPin
		),
	    op : UML!OutputPin (
			name <- 'resultOutput',
			upperBound <- ub --MODIF
		),
		ub	:	UML!LiteralInteger(
			value <- 1
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
		
	}	
}

abstract rule abstractConditionnalAndBranchingStatement{
	from
		s : JAVA!Statement(s.oclIsTypeOf(JAVA!AssertStatement)
							or s.oclIsTypeOf(JAVA!SwitchStatement)	
							or s.oclIsTypeOf(JAVA!ContinueStatement)	
							or s.oclIsTypeOf(JAVA!EmptyStatement)	
							or s.oclIsTypeOf(JAVA!SynchronizedStatement)	
							or s.oclIsTypeOf(JAVA!ThrowStatement)	
							or s.oclIsTypeOf(JAVA!BreakStatement)	
							or s.oclIsTypeOf(JAVA!SwitchCase)
							and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		pre	:	UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
}

rule assertStatement extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!AssertStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(		
			name <- 'AssertStatement-Incomplete'
		)
}


rule switchStatement extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SwitchStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'SwitchStatement-Incomplete'
		)
}

rule continue extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!ContinueStatement (s.notInInitializerOrFieldOrEnum and	s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'continue'
		)
}

rule empty extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!EmptyStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'empty'
		)
}

rule synchro extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SynchronizedStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Synchronized-incomplete'
		)
}

rule throw extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!ThrowStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'throw'
		),
		pos	:	UML!ControlFlow(
			name <- 'fromStructuredNodeToFinalNode',  
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,
			activity <- s.getContainerStructuredNode.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- t,
			target <- thisModule.resolveTemp(s.getOwningMethod.body, 'final'),
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		initialNode : UML!InitialNode(
			inStructuredNode <- t
		),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromPrecedingNodeToInitialNode',
			inStructuredNode <- t,
			source <- s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- initialNode,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		finalControlFlow: UML!ControlFlow(
			name <- 'fromPrecedingNodeToFinalNode',
			inStructuredNode <- t,
			source <- 	s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- final,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule break extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!BreakStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
			and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!OpaqueAction(
			name <- 'break'
		),
		pos	:	UML!ControlFlow(
			name <- 'fromOpaqueActionToFinalNode', 
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,
			activity <- s.getContainerStructuredNode.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- t,
			target <- thisModule.resolveTemp(s.refImmediateComposite(), 'fin'),
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		)
}

rule switchCase extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SwitchCase (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'SwitchCase-Incomplete'
		)
}

abstract rule abstractLoopAndTryStatement{
	from
		s : JAVA!Statement(s.oclIsTypeOf(JAVA!TryStatement)
							or s.oclIsTypeOf(JAVA!ForStatement)
							or s.oclIsTypeOf(JAVA!EnhancedForStatement)
							or s.oclIsTypeOf(JAVA!WhileStatement)
							or s.oclIsTypeOf(JAVA!DoStatement)
							and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,
			activity <- s.getContainerStructuredNode.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		pre	:	UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode.getSourceTargetOrOwnerSAN,
			activity <- s.getContainerStructuredNode.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- 	s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
}


rule forStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!ForStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'for'
		),
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>',
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitNodeToInitializer',
			inStructuredNode <- t,
			source <- ini,
			target <- s.initializers->first(),
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		id2	:	UML!ControlFlow(
			name <- 'fromInitializerToJoinNode',
			inStructuredNode <- t,
			source <- if (not s.initializers->first().oclIsKindOf(JAVA!TypeLiteral)) then
						s.initializers->first()
					  else OclUndefined endif,
			target <- jn,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		id3	:	UML!ControlFlow(
			name <- 'fromJoinNodeToDecisionNode',
			inStructuredNode <- t,
			source <- jn,
			target <- dec,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToBody',
			inStructuredNode <- t,
			source <- dec,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- uvt,
			weight <- we6
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode',
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf,
			weight <- we7
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		uvt	:	UML!LiteralBoolean(
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		
		id4	:	UML!ControlFlow(
			name <- 'fromBodyToUpdater',
			inStructuredNode <- t,
			source <- 	s.body.getSourceTargetOrOwnerSAN,			
			target <- s.updaters->first(),
			guard <- gu8,
			weight <- we8
		),
		gu8	:	UML!LiteralBoolean(
			value <- false
		),
		we8	:	UML!LiteralBoolean(
			value <- false
		),
		id5	:	UML!ControlFlow(
			name <- 'fromUpdaterToJoinNode',
			inStructuredNode <- t,
			source <- if (not s.updaters->first().oclIsKindOf(JAVA!TypeLiteral)) then
						s.updaters->first()
					  else OclUndefined endif,
			target <- jn,
			guard <- gu9,
			weight <- we9
		),
		gu9	:	UML!LiteralBoolean(
			value <- false
		),
		we9	:	UML!LiteralBoolean(
			value <- false
		)
}

rule enhancedForStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!EnhancedForStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'foreach'
		),
		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitNodeToActivityNode', 
			inStructuredNode <- t,
			source <- ini,
			target <- s.expression.getActivityNode(),
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		of	:	UML!ObjectFlow(
			name <- 'fromActivityNodeToExpansionRegion',
			inStructuredNode <- t,
			source <- s.expression.getActivityNode(),
			target <- er,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		er	:	UML!ExpansionRegion(
			inStructuredNode <- t
		),
		ier	:	UML!InitialNode(
			inStructuredNode <- er
		),
		fe1	:	UML!ControlFlow(
			name <- 'fromInitNodeToBody',
			inStructuredNode <- er,
			source <- ier,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		fe2	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- er,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- final,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- er
		),
		id2	:	UML!ControlFlow(
			name <- 'fromExpansionRegionToFinalNode',
			inStructuredNode <- t,
			source <- er,
			target <- thisModule.createActivityFinalNode(t),
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		)
}

rule whileStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!WhileStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'while'
		),
		
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitialNodeToJoinNode',
			inStructuredNode <- t,
			source <- ini,
			target <- jn,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToDecisionNode',
			inStructuredNode <- t,
			source <- jn,
			target <- dec,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>',
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToBody',
			inStructuredNode <- t,
			source <- dec,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- uvt,
			weight <- we5
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode',
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf,
			weight <- we6
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		uvt	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		id3	:	UML!ControlFlow(
			name <- 'fromBodyToJoinNode',
			inStructuredNode <- t,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- jn,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		)
}

rule doWhileStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!DoStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'doWhile'
		),
		
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitialNodeToJoinNode', 
			inStructuredNode <- t,
			source <- ini,
			target <- jn,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToBody',
			inStructuredNode <- t,
			source <- jn,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>',
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToJoinNode', 
			inStructuredNode <- t,
			source <- dec,
			target <- jn,
			guard <- uvt,
			weight <- we5
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode', 
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf,
			weight <- we6
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		uvt	:	UML!LiteralBoolean(
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		id3	:	UML!ControlFlow(
			name <- 'fromBodyToDecisionNode', 
			inStructuredNode <- t,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- dec,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		)
}

rule tryStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!TryStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'try'
		),
		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		ib	:	UML!ControlFlow(
			name <- 'fromInitialNodeToBody', 
			inStructuredNode <- t,
			source <- ini,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		bf	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- t,
			source <-   s.body.getSourceTargetOrOwnerSAN,
			target <- final,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
--		uvf	:	UML!LiteralBoolean(
--			value <- false
--		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule VariableDeclaration {
	from
		s	:	JAVA!VariableDeclarationStatement (	s.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
													and s.notInInitializerOrFieldOrEnum 
													and s.notInAnnotation
													and s.notInClassInstanceCreation --MODIF
												
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_'+s.fragments->first().name
		),		
		oFToForkNode : UML!ObjectFlow(
			name <- 'declare_'+s.fragments->first().name+'_object_flow_to_fork_node',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,	
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(s.fragments -> first().initializer,'op'),
			target <- forkNode,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			name <- 'declare_'+s.fragments->first().name+'_fork_node',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		icf	: UML!ControlFlow(
			name <- 'to_declare_'+s.fragments->first().name,
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- s.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		ocf	: UML!ControlFlow(
			name <- 'from_declare_'+s.fragments->first().name,
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- t,
			target <- s.getNext().getSourceTargetOrOwnerSAN,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		)
}

rule ifStatement {
	from
		s	:	JAVA!IfStatement (s.notInInitializerOrFieldOrEnum
				and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'If'
		),
		
		ini	:	UML!InitialNode(
			name <- 'InitialNode',
			inStructuredNode <- t
		),
		inToDecNContFl : UML!ControlFlow(
			name <- 'InitialNode to decisionNode',
			inStructuredNode <- t,
			source <- ini,
			target <- decNode,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		td	:	UML!ObjectFlow(
			name <- '<<decisionInputFlow>> - Test expression to DecisionNode',
			inStructuredNode <- t,
			source <- s.expression.getActivityNode(),
			target <- decNode,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		decNode	:	UML!DecisionNode(
			name <- 'DecisionNode - IfStatement',
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),		
		truThen	: UML!ControlFlow(
			name <- 'Then(true) - DecisionNode to ThenStatement',
			inStructuredNode <- t,
			source <- decNode,
			target <- s.thenStatement.getSourceTargetOrOwnerSAN,
			guard <- trueGuard,
			weight <- we3
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		trueGuard :	UML!LiteralBoolean(
			value <- true
		),
		falElse	: UML!ControlFlow(
			name <- 'Else(false) - DecisionNode to ElseStatement',
			inStructuredNode <- t,
			source <- decNode,
			target <- 	if s.elseStatement.oclIsUndefined() then 
							thisModule.createEmptyElse(s)
						else
							s.elseStatement.getSourceTargetOrOwnerSAN
						endif,	
			guard <- falseGuard,
			weight <- we4
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		falseGuard : UML!LiteralBoolean(
			value <- false
		),
		
		merNode	:	UML!MergeNode(
			name <- 'Merge Then and Else statements',
			inStructuredNode <- t
		),
		t2j	:	UML!ControlFlow(
			name <- 'Then statement to MergeNdoe',
			inStructuredNode <- t,
			source <- 	s.thenStatement.getSourceTargetOrOwnerSAN,
			target <- merNode,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		e2j	:	UML!ControlFlow(
			name <- 'Else statement to MergeNdoe',
			inStructuredNode <- t,
			source <- 	if s.elseStatement.oclIsUndefined() 
						then thisModule.createEmptyElse(s)
						else 
							s.elseStatement.getSourceTargetOrOwnerSAN
						endif,
			target <- merNode,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode	:	UML!ForkNode(
			name <- 'External and End ForkNode',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		mergToEndFnContFlow	:	UML!ControlFlow(
			name <- 'MergeNode to End ForkNode',
			inStructuredNode <- t,
			source <- merNode,
			target <- forkNode,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		)
}

rule labelStatement2StructuredActivity {
	from
		s : JAVA!LabeledStatement (
			(not s.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration)) 
			and s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- s.refImmediateComposite().oclType().toString(),
			inStructuredNode <- if s.oclIsKindOf(JAVA!UnresolvedLabeledStatement)then
									s.getCorrespondingDec.getStatement
								else
									s.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			node <- Sequence{	init, 
								s.body.getSourceTargetOrOwnerSAN,
								final
					}
					->flatten()						
		),
		init	:	UML!InitialNode(),
		final	:	UML!ActivityFinalNode(),		
		fcf : UML!ControlFlow(
			name <- 'fromInitBodyNodeToFinalNode', 
			inStructuredNode <- t,
			target <- final,
			source <- 	if (s.body.oclIsUndefined())
							then init
							else 
								if s.oclIsKindOf(JAVA!UnresolvedLabeledStatement)then
									s.getCorrespondingDec.body
								else 
									s.body.getSourceTargetOrOwnerSAN
								endif
						endif,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
}

rule catchClause {
	from
		s	:	JAVA!CatchClause (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
				and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'catch ' + if s.exception.type.type.oclIsUndefined() 
									then 'Unknown Exception'
									else s.exception.type.type.name
								endif,
			inStructuredNode <-  s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		ib	:	UML!ControlFlow(
			name <- 'fromInitialNodeToBody',
			inStructuredNode <- t,
			source <- ini,
			target <- s.body.getSourceTargetOrOwnerSAN,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		bf	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- t,
			source <- 	s.body.getSourceTargetOrOwnerSAN,
			target <- final,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
--		uvf	:	UML!LiteralBoolean(
--			value <- false
--		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		
		tc	:	UML!ControlFlow(
			name <- if s.exception.type.type.oclIsUndefined() 
						then 'Unknown Exception'
						else s.exception.type.type.name
					endif,
			inStructuredNode <-s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- 	s.refImmediateComposite().body.getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- ivs,
			weight <- we3
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		ivs	:	UML!InstanceValue(
			name <- if s.exception.type.type.oclIsUndefined() 
									then 'Unknown Exception'
									else s.exception.type.type.name
								endif,
			type <- s.exception.type.type.excludeUnresolvedTypeDec
		)
		
}

abstract rule classInstanceCreation2CreateObject {
	from
		ci	:	JAVA!ClassInstanceCreation (	ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
												and ci.notInInitializerOrFieldOrEnum 
												and ci.notInAnnotation
												and ci.notInClassInstanceCreation --MODIF
		)
	to 		
		createObjectAction : UML!CreateObjectAction(
			name <- 'Constructor Invocation of '+ ci.originalCompilationUnit.name,
			classifier <- 	if(ci.type.type.oclIsKindOf(JAVA!ParameterizedType))then
								ci.method.abstractTypeDeclaration.excludeUnresolvedMethodDec
							else ci.type.type.excludeUnresolvedTypeDec endif,
			result <- op,			
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),		
		
		
		outObjCreateOA : UML!ObjectFlow(
			name <- 'fromOutputConstrucotrInvocationToForkNode', --OK
			--activity <- ci.getOwningMethod,--ERROR MODIF
			source <- op,
			target <- forkNode,
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'Result of constructor invocation of ' + ci.originalCompilationUnit.name,
			type <- if(ci.type.type.oclIsKindOf(JAVA!ParameterizedType))then
						ci.method.abstractTypeDeclaration.excludeUnresolvedMethodDec
					else ci.type.type.excludeUnresolvedTypeDec endif,
			outgoing <- outObjCreateOA,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		inObjCallOA : UML!ObjectFlow(
			name <- 'fromforkNodeToCallOperationAction', --OK
			source <- forkNode,
			target <- inputPin,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			incoming <- outObjCreateOA,
			outgoing <- Sequence{inObjCallOA},
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),	
		co	:	UML!CallOperationAction(
			name <- ci.method.name,
			operation <- thisModule.resolveTemp(ci.method, 'operation'),
			target <- inputPin,
			argument <- inputPin
		),
		inputPin : UML!InputPin (
			name <- 'target',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		)
}

rule classInstanceCreation2CreateObjectNoArgument extends classInstanceCreation2CreateObject{
	from
		ci	:	JAVA!ClassInstanceCreation (
			ci.arguments -> isEmpty()
			and ci.notInClassInstanceCreation --MODIF
		)
	to 		
		createObjectAction : UML!CreateObjectAction(),
		co	:	UML!CallOperationAction(),
		inObjCallOA : UML!ObjectFlow(
			--source <- apn
		)
		--apn : UML!ActivityParameterNode()
	do{
		thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode 
				-> union(Sequence{co});
		thisModule.resolveTemp(ci.getOwningMethod, 'act').edge
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').edge 
				-> union(Sequence{inObjCallOA});
	}
}

rule classInstanceCreation2CreateObjectArgument extends classInstanceCreation2CreateObject{
	from
		ci	:	JAVA!ClassInstanceCreation (	
			ci.arguments -> notEmpty()
			and ci.notInClassInstanceCreation --MODIF
		)
	to 		
		createObjectAction : UML!CreateObjectAction(),
		inputPin : UML!InputPin (),
		inObjCallOA : UML!ObjectFlow(),
		co	:	UML!CallOperationAction(),
		objFlow : UML!ObjectFlow(
			name <- 'fromArgumentToCallOperationAction',
			source <- thisModule.resolveTemp(ci.arguments->first(), 'op'),
			target <- inputPin,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		controlFlow : UML!ControlFlow(
			name <- 'fromIntialNodeToLastStatement',
			inStructuredNode <- ci.getStatement.getStatement.getSourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(ci.getStatement.getStatement.getSourceTargetOrOwnerSAN, 'init'),
			target <- ci.getStatement.getStatement.getSourceTargetOrOwnerSAN,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode 
				-> union(Sequence{co});
		thisModule.resolveTemp(ci.getOwningMethod, 'act').edge
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').edge 
				-> union(Sequence{inObjCallOA,objFlow});
	}
}

abstract rule constructorAndMethod2Activity{
	from
		construcOrMethodDec : JAVA!AbstractMethodDeclaration(
			not construcOrMethodDec.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
		)
	to
		act	:	UML!Activity(),
		operation : UML!Operation(
			name <- if (not construcOrMethodDec.oclIsKindOf(JAVA!MethodDeclaration)) then
						'Constructor_'+construcOrMethodDec.getConstructorName
					else 'Method_'+construcOrMethodDec.getMethodName endif,
			method <- act,
			ownedParameter <- construcOrMethodDec.parameters
								-> collect(param |thisModule.Parameters2ActivityParameter(param))
		)
}


--original
--rule constructor extends constructorAndMethod2Activity {
--	from
--		construcOrMethodDec : JAVA!ConstructorDeclaration(construcOrMethodDec.notInAnnotation)
--	to
--		act	:	UML!Activity(
--			name <- construcOrMethodDec.getConstructorName,
--			visibility <- construcOrMethodDec.getAbsMethDecVisibility
--		)
--	do{
--		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
--			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
--				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
--			else OclUndefined endif;
--		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
--			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
--				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
--					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
--				else OclUndefined endif
--			else OclUndefined endif;
--	}	
--}
--MODIF
rule constructor extends constructorAndMethod2Activity {
	from
		construcOrMethodDec : JAVA!ConstructorDeclaration(construcOrMethodDec.notInAnnotation
			--the constructor declaration does not belong to a ClassInstanceCreation
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
			and construcOrMethodDec.notInEnumDeclaration --MODIF
			)
	to
		act	:	UML!Activity(
			--name <- construcOrMethodDec.getConstructorName,
			--name <- '3098'.concat(construcOrMethodDec.getConstructorName).concat(construcOrMethodDec.refImmediateComposite().bodyDeclarations->first().name),
			name <- '3098'.concat(construcOrMethodDec.getConstructorName),
			visibility <- construcOrMethodDec.getAbsMethDecVisibility
			
			
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}	
}

abstract rule abstractConstructorCall2CreateObject {
	from
		ci	:	JAVA!AbstractMethodDeclaration(
			ci.oclIsTypeOf(JAVA!SuperConstructorInvocation)
			or ci.oclIsTypeOf(JAVA!ConstructorInvocation)
			and ci.notInClassInstanceCreation --MODIF
		)
	to 
		t	:	UML!StructuredActivityNode(
			inStructuredNode <-	ci.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ci.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		icf	: UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inStructuredNode <- ci.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- ci.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- ci.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
}

rule superConstructorCall2CreateObject {
	from
		ci	:	JAVA!SuperConstructorInvocation (
			ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
			and ci.notInInitializerOrFieldOrEnum 
			and ci.notInAnnotation
			and ci.notInClassInstanceCreation --MODIF
		)
	to 
		t	:	UML!StructuredActivityNode(
			name <- 'Super constructor invocation of '+ ci.originalCompilationUnit.name	,
			inStructuredNode <- ci.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- ci.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule constructorCall2CreateObject {
	from
		ci	:	JAVA!ConstructorInvocation (
			ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
			and ci.notInInitializerOrFieldOrEnum 
			and ci.notInAnnotation
			and ci.notInClassInstanceCreation --MODIF
		)
	to 
		t	:	UML!StructuredActivityNode(
			name <- 'Constructor invocation of '+ ci.originalCompilationUnit.name,
			inStructuredNode <- ci.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- ci.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule Methods2Activity extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(	
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			not construcOrMethodDec.isVoidMethod
				and
		 	not construcOrMethodDec.isBuggedModiscoMethod
				and
		 	construcOrMethodDec.notInAnnotation	
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
			and construcOrMethodDec.notInEnumDeclaration --MODIF
		)
	to
		act	:	UML!Activity(
			--name <- construcOrMethodDec.getMethodName,
			name <- '3170'.concat(construcOrMethodDec.getMethodName),
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody',
			activity <- act,
			target <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			source <- init,
			guard <- gu,
			weight <- we
		),
		
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			guard <- gu2,
			weight <- we2
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityBugModisco extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	( 
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isBuggedModiscoMethod
				and
			construcOrMethodDec.notInAnnotation
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
		)
	to
		act	:	UML!Activity(
			--name <-construcOrMethodDec.getMethodName,
			name <- '3221'.concat(construcOrMethodDec.getMethodName),
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody2',
			activity <- act,
			target <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			source <- init,
			guard <- gu,
			weight <- we
		),
		
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			guard <- gu2,
			weight <- we2
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

--original
--rule VoidMethod2Activity extends constructorAndMethod2Activity {
--	from
--		construcOrMethodDec	:	JAVA!MethodDeclaration	(
--			(not construcOrMethodDec.body.oclIsUndefined()) 
--				and
--			construcOrMethodDec.isVoidMethod
--				and
--			construcOrMethodDec.notInAnnotation	
--		)
--	to
--		act	:	UML!Activity(
--			name <- construcOrMethodDec.getMethodName,
--			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
--			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
--		),
--		
--		init	:	UML!InitialNode(
--			activity <- act
--		),
--		icf : UML!ControlFlow(
--			name <- 'fromIntialNodeToBody',
--			activity <- act,
--			target <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
--			source <- init 
--		),
--		
--		final	:	UML!ActivityFinalNode(
--			activity <- act
--		),
--		fcf : UML!ControlFlow(
--			name <- 'fromBodyToFinalNode',
--			activity <- act,
--			target <- final,
--			source <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN
--		)
--	do{
--		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
--			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
--				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
--			else OclUndefined endif;
--		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
--			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
--				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
--					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
--				else OclUndefined endif
--			else OclUndefined endif;
--	}		
--}
--MODIF
rule VoidMethod2Activity extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isVoidMethod
				and
			construcOrMethodDec.notInAnnotation	
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
			
		)
	to
		act	:	UML!Activity(
			--name <- construcOrMethodDec.getMethodName,
			name <- '3269'.concat(construcOrMethodDec.getMethodName), --MODIF
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody3',
			activity <- act,
			target <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			source <- init,
			guard <- gu,
			weight <- we
		),
		
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body.getSourceTargetOrOwnerSAN,
			guard <- gu2,
			weight <- we2
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(	
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			not construcOrMethodDec.isVoidMethod
				and
		 	not construcOrMethodDec.isBuggedModiscoMethod
				and
		 	construcOrMethodDec.notInAnnotation
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
			and construcOrMethodDec.notInInterfaceDeclaration --MODIF
		)
	to
		act	:	UML!Activity(
			--name <- construcOrMethodDec.getMethodName,
			name <- '3318'.concat(construcOrMethodDec.getMethodName),
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityBugModiscoEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	( 
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isBuggedModiscoMethod
				and
			construcOrMethodDec.notInAnnotation
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
		)
	to
		act	:	UML!Activity(
			--name <-construcOrMethodDec.getMethodName,
			name <- '3361'.concat(construcOrMethodDec.getMethodName),
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}
--original
--rule VoidMethod2ActivityEmptyBody extends constructorAndMethod2Activity {
--	from
--		construcOrMethodDec	:	JAVA!MethodDeclaration	(
--			(construcOrMethodDec.body.oclIsUndefined()) 
--				and
--			construcOrMethodDec.isVoidMethod
--				and
--			construcOrMethodDec.notInAnnotation
--		)
--	to
--		act	:	UML!Activity(
--			--name <- construcOrMethodDec.getMethodName,
--			name <- '3402',
--			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
--			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
--		),
--		
--		init	:	UML!InitialNode(
--			activity <- act
--		),
--		final	:	UML!ActivityFinalNode(
--			activity <- act
--		),
--		icf : UML!ControlFlow(
--			name <- 'fromInitialNodeToFinalNode',
--			activity <- act,
--			target <- final,
--			source <- init
--		)		
--	do{
--		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation <-
--			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
--				thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation -> append(operation)
--			else OclUndefined endif;
--		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior <-
--			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
--				if (construcOrMethodDec.getInstanciedClass.oclIsTypeOf(JAVA!ClassDeclaration)) then
--					thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior -> append(act)
--				else OclUndefined endif
--			else OclUndefined endif;
--	}		
--}
--MODIF
rule VoidMethod2ActivityEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isVoidMethod
				and
			construcOrMethodDec.notInAnnotation
			and construcOrMethodDec.notInClassInstanceCreation --MODIF
			and construcOrMethodDec.notInInterfaceDeclaration --MODIF
		)
	to
		act	:	UML!Activity(
			--name <- construcOrMethodDec.getMethodName,
			name <- '3402'.concat(construcOrMethodDec.getMethodName), --MODIF,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
				if (construcOrMethodDec.getInstanciedClass.oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule methodCallExpressionNullArgument {
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()
			and mi.notInInitializerOrFieldOrEnum
			and mi.arguments
					-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
					-> notEmpty()
			and mi.notInClassInstanceCreation --MODIF
		)
	to
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,		
			outgoing <- thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow'),
			incoming <- thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow'),
			object <- thisModule.resolveTemp(mi.refImmediateComposite(), 'inputCFA'),
			structuralFeature <- if (mi.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										mi.method.parameters
																		-> at(mi.arguments
																				-> indexOf(mi.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
											express.getFieldDec
									else OclUndefined endif										
								else OclUndefined endif,
			result <- thisModule.createOutputPin(mi.expression, 'clearStructuralFeatureActionOutput')		
		)
	do{
		---Redefinition of element for this case, using the elements from the rule 'expressionStatement' and its extension
		---of 'abstractExpressStatement'
		thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').name 
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').oclIsUndefined()) then
					'fromInitNodeToClearStructuralFeatureActionInit'
				else OclUndefined endif;
		thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').target
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'initialControlFlow').oclIsUndefined()) then
					clearStructuralFeature
				else OclUndefined endif;
		thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').name 
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').oclIsUndefined()) then
					'fromClearStructuralFeatureActionToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').source 
			<- 	if (not thisModule.resolveTemp(mi.refImmediateComposite(), 'finalControlFlow').oclIsUndefined()) then
					clearStructuralFeature
				else OclUndefined endif;
	}
}

abstract rule methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()	
			and mi.notInInitializerOrFieldOrEnum
			and if not mi.arguments.oclIsUndefined() then
					mi.arguments
						-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
						-> isEmpty()
				else true endif	
			and mi.notInClassInstanceCreation --MODIF
		)
	to
			co	:	UML!CallOperationAction(
				name <- mi.method.name,
				operation <- thisModule.resolveTemp(mi.method, 'operation'),
				inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
				activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
				target <- inputPin,
				result <- op
			),
			of1	:	UML!ObjectFlow (
				name <- 'fromExpressionOutputToCallOperationAction'.concat('_'+mi.method.name),
				inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
				activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
				target <- inputPin,
				source <- thisModule.resolveTemp(mi.expression, 'op'),
				guard <- gu,
				weight <- we
			),
			gu	:	UML!LiteralBoolean(
				value <- false
			),
			we	:	UML!LiteralBoolean(
				value <- false
			),
			inputPin	:	UML!InputPin (
				name <- 'objectInput',
				incoming <- of1,
				upperBound <- li
			),
			li	:	UML!LiteralInteger(
				value <- 1
			),
			op	:	UML!OutputPin (
				name <- 'callOperationActionOutput',
				upperBound <- up
			),
			up	:	UML!LiteralInteger(
				value <- 1
			)
}

rule methodCallExpressionNotNullArgumentNotNullExpress extends methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()	
			and mi.notInInitializerOrFieldOrEnum
			and mi.notInClassInstanceCreation --MODIF
			and if not mi.arguments.oclIsUndefined() then
					mi.arguments
						-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
						-> isEmpty()
				else true endif		
			and not mi.expression.oclIsUndefined()	
			and if (not mi.method.oclIsUndefined()) then
					not (mi.method.name = 'clear')
				else false endif
		)
	to
		co	:	UML!CallOperationAction(
			name <- mi.method.name,
			argument <- inputPinArgue,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),		
		inputPinArgue : UML!InputPin (
			name <- 'target1',--MODIF
			incoming <- if (mi.getOwningMethodInvocation.oclIsUndefined())then
							thisModule.createFlowsForMethodInvocation(co, mi)
						else OclUndefined endif,
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		)
}

rule createFlowsForMethodInvocation(co : UML!CallOperationAction, mi : JAVA!MethodInvocation){
	to
		ofArgue	:	UML!ObjectFlow (
			name <- 'fromArgumentToCallOperationAction',
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(mi.expression, 'op'),
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		controlFlow : UML!ControlFlow(
			name <- 'ToCallOperationAction',
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- co,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		ofArgue;
	}
}

rule methodCallExpressionNotNullArgumentNotNullExpressClear extends methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()
			and mi.notInClassInstanceCreation --MODIF
			and mi.notInInitializerOrFieldOrEnum
			and if not mi.arguments.oclIsUndefined() then
					mi.arguments
						-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
						-> isEmpty()
				else true endif		
			and not mi.expression.oclIsUndefined()	
			and if (not mi.method.oclIsUndefined()) then
					mi.method.name = 'clear'
				else false endif
		)
	to
		co	:	UML!CallOperationAction(
			name <- mi.method.name,
			argument <- inputPin,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),			
		inputPin :	UML!InputPin ()
}		

rule methodCallExpressionNotNullArgumentNullExpress extends methodCallExpressionNotNullArgument{
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()
			and mi.notInClassInstanceCreation --MODIF
			and mi.notInInitializerOrFieldOrEnum
			and if not mi.arguments.oclIsUndefined() then
					mi.arguments
						-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
						-> isEmpty()
				else true endif		
			and mi.expression.oclIsUndefined()	
			and if (not mi.method.oclIsUndefined()) then
					not (mi.method.name = 'clear')
				else false endif
		)
	to		
		co : UML!CallOperationAction(
			argument <- mi.arguments->collect(a | 	if a.isPrimitiveType then
															thisModule.createArgument(a)
														else
															thisModule.createArgumentNotPrimitiv(a)
														endif	
														),
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN											
		),
		of1	:	UML!ObjectFlow (),
		read	:	UML!ReadSelfAction (
			result <- selfResult,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		selfResult	:	UML!OutputPin (
			name <- 'resultReadSelfActionOutput',
			outgoing <- of1,
			upperBound <- up2
		),
		up2	:	UML!LiteralInteger(
			value <- 1
		)
}

rule superMethodCallExpression {
	from
		mi	:	JAVA!SuperMethodInvocation (mi.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
				and mi.notInClassInstanceCreation --MODIF	
		)
	to
		cba	:	UML!CallBehaviorAction(
			name <- mi.method.name,
			inStructuredNode <- mi.getStatement.getSourceTargetOrOwnerSAN,
			activity <- mi.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- mi.arguments->collect(a | 	if a.isPrimitiveType then
														thisModule.createArgument(a)
													else
														thisModule.createArgumentNotPrimitiv(a)
													endif	
													),
			result <- op
		),
		op	:	UML!OutputPin (
			name <- 'resultOutput',
			upperBound <- ub --MODIF
		),
		ub	:	UML!LiteralInteger(
			value <- 1
		)
}

abstract rule Parameters2ActivityParameterAndParamNode{
	from
		param	:	JAVA!SingleVariableDeclaration(
			param.notInInitializerOrFieldOrEnum
			and param.notInClassInstanceCreation --MODIF
		)
	to
		apn	:	UML!ActivityParameterNode(
			name <- param.name,
			type <- if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec 
						endif
					endif,
			parameter <- paramAct,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		paramAct	:	UML!Parameter(
			name <- param.name,
			type <- if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec 
						endif
					endif
		)
}

rule Parameters2ActivityParameterAndParamNodeNotMethInvoc extends Parameters2ActivityParameterAndParamNode{
	from
		param	:	JAVA!SingleVariableDeclaration(
			let singlVar : JAVA!SingleVariableAccess = 
				param.usageInVariableAccess
						-> first()
			in
				if not singlVar.oclIsUndefined()then
					not singlVar.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation)
					or (
						if (singlVar.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation))then
							singlVar.refImmediateComposite().arguments
															-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
															-> notEmpty()
						else true endif
					)
				else true endif	
				and param.notInClassInstanceCreation --MODIF
				and param.notInInterfaceDeclaration --MODIF
				and param.notInEnumDeclaration --MODIF
				
		) 
	to	
		
		paramAct	:	UML!Parameter(),
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode3', --MODIF
			activity <- param.getOwningMethod,
			target <- thisModule.resolveTemp(param.getExpressionOfSingleVarDec, 'ip'),
			source <- apn,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		apn	:	UML!ActivityParameterNode()
		
	do{
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule Parameters2ActivityParameterAndParamNodeMethInvoc extends Parameters2ActivityParameterAndParamNode{
	from
		param	:	JAVA!SingleVariableDeclaration(
			let singlVar : JAVA!SingleVariableAccess = 
				param.usageInVariableAccess
						-> first()
			in
				if not singlVar.oclIsUndefined()then
					singlVar.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation)
					or (
						if (singlVar.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation))then
							not singlVar.refImmediateComposite().arguments
																-> select(argue | argue.oclIsKindOf(JAVA!NullLiteral))
																-> notEmpty()
						else false endif
					)
				else false endif
				and param.notInClassInstanceCreation --MODIF
		) 
	to	
		apn	:	UML!ActivityParameterNode(),		
		paramAct	:	UML!Parameter()
	do{
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule parameterizedType {
	from
		s	:	JAVA!ParameterizedType(
				s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!Class(
			name <- s.typeArguments -> first().type.name
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}		
}

rule VariableAssignmentNoList {
	from
		as : JAVA!Assignment (	as.isVariableAssignmentNoList
								and as.notInInitializerOrFieldOrEnum 
								and as.notInAnnotation
								and as.notInClassInstanceCreation --MODIF
								and as.notInEnumDeclaration --MODIF
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- as.getStatement.getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_'+if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
									as.leftHandSide.element.name
								else as.leftHandSide.field.variable.name endif
		),	
		
		va	:	UML!InputPin(
			name <- 'valueInput',
			incoming <- if (as.rightHandSide.oclIsKindOf(JAVA!SingleVariableAccess))then
							thisModule.resolveTemp(as.rightHandSide.variable, 'ob')
						else OclUndefined endif,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		objectFlowForObject : UML!ObjectFlow(
			name <- 'fromLeftHandSideStatementToInputObject',
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- if (not as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
						thisModule.resolveTemp(as.leftHandSide.expression, 'op')
					  else OclUndefined endif,
			target <- ip,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		ip	:	UML!InputPin(
			name <- 'objectInput',
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		initial : UML!InitialNode(
			inStructuredNode <- t
		),
		icf2	: UML!ControlFlow(
			name <- 'fromInitialNodeToStructuredActivityNode',
			inStructuredNode <- t,
			source <- initial,
			target <- t,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		contFlow : UML!ControlFlow(
			name <- 'fromStructuredActivityNodeToAddStructuralFeatureValueAction',
			inStructuredNode <- t,
			source <- t,
			target <- strucFeatAction,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			isReplaceAll <- true,
			object <- ip,
			value <- va,
			structuralFeature <- if (not as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
									if (not as.leftHandSide.field.oclIsUndefined())then
										as.leftHandSide.field.getFieldDec
									else OclUndefined endif	
								 else OclUndefined endif,
			inStructuredNode <- t
		),		
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		asfvaToFinalNode	: UML!ControlFlow(
			name <- 'fromAddStructuralFeatureValueActionToFinalNode',
			inStructuredNode <- t,
			source <- strucFeatAction,
			target <- final,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(as.getStatement, 'initialControlFlow').name 
			<- if not thisModule.resolveTemp(as.getStatement, 'initialControlFlow').oclIsUndefined()then
					'fromInitialNodeToInternalCurrent'
				else OclUndefined endif;
		thisModule.resolveTemp(as.getStatement, 'initialControlFlow').target 
			<- if not thisModule.resolveTemp(as.getStatement, 'initialControlFlow').oclIsUndefined()then
					thisModule.createStructuredActivityNode(t, 'declare_'+
							if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))
								then as.leftHandSide.element.name
							else as.leftHandSide.field.variable.name endif
						)
				else OclUndefined endif;
		thisModule.resolveTemp(as.getStatement, 'finalControlFlow').name 
			<- if not thisModule.resolveTemp(as.getStatement, 'finalControlFlow').oclIsUndefined()then
					'fromInternalCurrentToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(as.getStatement, 'finalControlFlow').source 
			<- if not thisModule.resolveTemp(as.getStatement, 'finalControlFlow').oclIsUndefined()then
						thisModule.createStructuredActivityNode(t, 'declare_'+
							if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))
								then as.leftHandSide.element.name
							else as.leftHandSide.field.variable.name endif
						)
				else OclUndefined endif;	
	}	
}

rule localVariableAssignmentNoList {
	from
		as	:	JAVA!Assignment  (	as.isLocaleVariableAssignmentNoList
									and as.notInInitializerOrFieldOrEnum 
									and as.notInAnnotation
									and as.notInClassInstanceCreation --MODIF
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_' + as.leftHandSide.variable.name
		),		
		objectFlow : UML!ObjectFlow(
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'declare_' + as.leftHandSide.variable.name,
			source <- 	as.rightHandSide.getStatement.getSourceTargetOrOwnerSAN,
			target <- forkNode,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			name <- 'fromRightHandSide',
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		icf	: UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inStructuredNode <- as.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- as.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <-	as.getStatement.getPreceding().getSourceTargetOrOwnerSAN,
			target <- t,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		)
}

rule variableAssignementListOrArray {
	from
		iva	:	JAVA!Assignment (	(
										iva.isVariableAssignmentList										
										or
										iva.isAbsDecMethContainedAndArray
									)	
									and iva.notInInitializerOrFieldOrEnum 
									and iva.notInAnnotation
									and iva.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Variable assignement - List or array',
			inStructuredNode <- iva.refImmediateComposite().refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		
		
		--Object to fork
		objFlowForObjInFork : UML!ObjectFlow(
			name <- 'fromLeftHandSideToFork',
			source <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess) 
							and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
						)then
							iva.leftHandSide.expression
						else
							iva.leftHandSide.getStatement.getSourceTargetOrOwnerSAN
						endif,
			target <- forkNode,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		--Fork to ClearStruc.Feature
		objFlowForObjCFS : UML!ObjectFlow(
			name <- 'fromForkToClearStructuralFeatureInput',
			source <- forkNode,
			target <- inputClearStrucFeat,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		--Fork to Exp.Region
		objFlowForObjExpReg	: UML!ObjectFlow(
			name <- 'fromForkToExpansionRegionInput',
			source <- forkNode,
			target <- inputExpReg,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		forkNode : UML!ForkNode(
			name <- 'fromLeftHandSide',
			inStructuredNode <- iva.refImmediateComposite().refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		--ClearStruc.Feature 
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			object <- inputClearStrucFeat,
			outgoing <- contFlowCSFExpReg,
			structuralFeature <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess)
										and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
									)then
										if (not iva.leftHandSide.field.oclIsUndefined())then
											iva.leftHandSide.field.getFieldDec
										else OclUndefined endif	
									else
										if (iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess))then
											if (iva.leftHandSide.array.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.array.getFieldDec
											else OclUndefined endif	
										else 
											if (iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.getFieldDec
											else OclUndefined endif
										endif	
									endif,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		
		--ClearStruc.Feature to Exp.Region
		contFlowCSFExpReg	:	UML!ControlFlow(
			name <- 'fromClearStructuralFeatureActionToExpansionRegion',
			source <- clearStructuralFeature,
			target <- expReg,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		--ValueSpecAction to 'insertAt' object flow
		valueSpecAction	:	UML!ValueSpecificationAction(
			result <- op,
			value <- literUnlimNatur,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		literUnlimNatur : UML!LiteralUnlimitedNatural(
			value <- -1
		),
		--Output of ValueSpecAction to input of Exp.Region 'insertAt'
		objFlowForObjInsertAt : UML!ObjectFlow(
			name <- 'fromValueSpecificationActionOutputToExpansionRegionInput',
			source <- op,
			target <- inputExpRegInsertAt,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu5,
			weight <- we5
		),
		gu5	:	UML!LiteralBoolean(
			value <- false
		),
		we5	:	UML!LiteralBoolean(
			value <- false
		),
		op : UML!OutputPin(
			name <- 'outputValueSpecAction',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		),
		--Exp.Region to AddStruct.FeatureValue
		expReg : UML!ExpansionRegion(
			incoming <- contFlowCSFExpReg,
			inputElement <- expNode,
			inStructuredNode <- iva.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- iva.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		addStructuralFeatureAction : UML!AddStructuralFeatureValueAction(
			name <- 'add',
			isReplaceAll <- false,
			inStructuredNode <- expReg,
			object <- inputObjectAddStrucFeat,
			value <- valueExpression,			
			insertAt <- insertAtValueSpecAction,
			structuralFeature <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess)
										and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
									)then
										if (not iva.leftHandSide.field.oclIsUndefined())then
											iva.leftHandSide.field.getFieldDec
										else OclUndefined endif	
									else
										if (iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess))then
											if (iva.leftHandSide.array.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.array.getFieldDec
											else OclUndefined endif	
										else	
											if (iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess))then
												iva.leftHandSide.getFieldDec
											else OclUndefined endif
										endif	
									endif
		),
		expNode	:	UML!ExpansionNode(
			name <- 'inputElementOfExpansionRegion',
			inStructuredNode <- expReg
		),
		objFlowExpRegToAddStruct : UML!ObjectFlow(
			name <- 'fromInputExpRegToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputExpReg,
			target <- inputObjectAddStrucFeat,
			guard <- gu6,
			weight <- we6
		),
		gu6	:	UML!LiteralBoolean(
			value <- false
		),
		we6	:	UML!LiteralBoolean(
			value <- false
		),
		inputExpReg : UML!InputPin(
			name <- 'objectInputOfExpansionRegion',
			inStructuredNode <- expReg,
			lower <- 1,
			upper <- 1,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		inputObjectAddStrucFeat : UML!InputPin(
			name <- 'objectInputAddStructuralFeatureValueAction',
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		objFlowValueToAddStruct	: UML!ObjectFlow(
			name <- 'fromInputExpRegValueToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputClearStrucFeat,
			target <- valueExpression,
			guard <- gu7,
			weight <- we7
		),
		gu7	:	UML!LiteralBoolean(
			value <- false
		),
		we7	:	UML!LiteralBoolean(
			value <- false
		),
		inputClearStrucFeat : UML!InputPin(
			name <- 'objectInputOfClearStructuralFeature',
			upperBound <- li3
		),
		li3	:	UML!LiteralInteger(
			value <- 1
		),
		valueExpression	: UML!InputPin(
			name <- 'valueInputAddStructuralFeatureValueAction',
			upperBound <- li4
		),
		li4	:	UML!LiteralInteger(
			value <- 1
		),
		objFlowInsertAtToAddStruct : UML!ObjectFlow(
			name <- 'fromInputExpRegInsertAtToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputExpRegInsertAt,
			target <- insertAtValueSpecAction,
			guard <- gu8,
			weight <- we8
		),
		gu8	:	UML!LiteralBoolean(
			value <- false
		),
		we8	:	UML!LiteralBoolean(
			value <- false
		),
		inputExpRegInsertAt : UML!InputPin(	
			name <- 'insertAtInput',
			inStructuredNode <- expReg,
			lower <- 1,
			upper <- 1,
			upperBound <- li5
		),
		li5	:	UML!LiteralInteger(
			value <- 1
		),
		insertAtValueSpecAction	: UML!InputPin(
			name <- 'insertAtInputAddStructuralFeatureValueAction',
			upperBound <- li6
		),
		li6	:	UML!LiteralInteger(
			value <- 1
		)
}

rule conditionalExpression { --simplifed mapping in case of empty else branch
	from
		ifs	:	JAVA!ConditionalExpression (ifs.notInInitializerOrFieldOrEnum and ifs.notInAnnotation
				and ifs.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- ifs.getStatement.getSourceTargetOrOwnerSAN,	
			activity <- ifs.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			name <- 'Conditionnal'
		),		
		td	:	UML!ObjectFlow(
			name <- 'fromActivityNodeToDecisionNode',
			inStructuredNode <- t,
			source <- ifs.expression.getActivityNode(),
			target <- dec,
			name <- '<<decisionInputFlow>>',
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		tru	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToThenStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- ifs.thenExpression.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ifs.thenExpression.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- uvt,
			weight <- we2
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		fal	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToElseStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- 	if ifs.elseExpression.oclIsUndefined()
						then thisModule.createEmptyElse(ifs)
						else 
							ifs.elseExpression.getStatement.getSourceTargetOrOwnerSAN								
						endif,
			guard <- uvf,
			weight <- we3
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		uvt	:	UML!LiteralBoolean(
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),		
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToFinalNode',
			inStructuredNode <- t,
			source <- jn,
			target <- final,
			guard <- gu4,
			weight <- we4
		),
		gu4	:	UML!LiteralBoolean(
			value <- false
		),
		we4	:	UML!LiteralBoolean(
			value <- false
		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule expression{
	from
		s	:	JAVA!Expression (					
					(s.refImmediateComposite().oclIsKindOf(JAVA!IfStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!ForStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!DoStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!EnhancedForStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!WhileStatement)
							or not s.refImmediateComposite().isReturnStateGeneratingObjectFlow
					 ) 
					 	and
					 if s.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement) then
					 	not s.refImmediateComposite().isReturnSimpleImplicitThis
					 else true endif	
					 	and 
					 s.notInInitializerOrFieldOrEnum 
					 	and 
					s.notInAnnotation 
						and
					s.alreadyManage
					and s.notInClassInstanceCreation --MODIF
		)
	to
		t : UML!StructuredActivityNode(
			name <- 'expression',
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule expressionForVarDeclaration{
	from
		s	:	JAVA!Expression(
					(	s.refImmediateComposite().oclIsKindOf(JAVA!VariableDeclarationFragment) 
								and
						s.refImmediateComposite().refImmediateComposite().oclIsKindOf(JAVA!VariableDeclarationStatement) 
					 ) 
						and
					s.notInInitializerOrFieldOrEnum 
						and 
					s.notInAnnotation 
						and 
					s.alreadyManage
					and s.notInClassInstanceCreation --MODIF
				)					 
	to
		t : UML!StructuredActivityNode(
			name <- 'expression',
			inStructuredNode <- s.refImmediateComposite().refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

abstract rule explicitThis2readSelf {
	from
		this	:	JAVA!ThisExpression (this.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
				and this.notInClassInstanceCreation --MODIF
				and this.notInEnumDeclaration --MODIF
		)
	to
		read	:	UML!ReadSelfAction (
			result <- op,
			inStructuredNode <- this.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- this.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		op	:	UML!OutputPin (
			name <- 'resultReadSelfActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

---Concerns the use of field directly using 'this'
---not directly in a return statement
rule explicitThis2readSelfNotInReturn extends explicitThis2readSelf{
	from
		this	:	JAVA!ThisExpression (
			not this.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement)
			and this.notInClassInstanceCreation --MODIF
		)
	to		
		read	:	UML!ReadSelfAction (),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToExpression',
			inStructuredNode <- this.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- this.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			source <- thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'init'),
			target <- read,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
	do{
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').name
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					'fromExpressionToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').source
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					read
				else OclUndefined endif;
	}	
}

---Concerns the use of field directly using 'this'
---directly in a return statement
rule explicitThis2readSelfInReturn extends explicitThis2readSelf{
	from
		this	:	JAVA!ThisExpression (
			this.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement)
			and this.notInClassInstanceCreation --MODIF
		)
	to		
		read	:	UML!ReadSelfAction (),
		finalControlFlow: UML!ControlFlow(
			name <- 'fromFinalNodeToExpression',
			activity <- this.getStatement.getOwningMethod,
			source <- thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'final'),
			target <- thisModule.resolveTemp(this.getStatement, 't')
		)
	do{
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').name
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					'fromExpressionToFinalNode'
				else OclUndefined endif;
		thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').source
			<- 	if not thisModule.resolveTemp(this.getStatement.refImmediateComposite(), 'fcf').oclIsUndefined() then
					thisModule.resolveTemp(this.getStatement, 't')
				else OclUndefined endif;
	}	
}


rule parenthesizedExpression {
	from
		s	:	JAVA!ParenthesizedExpression (s.notInInitializerOrFieldOrEnum and s.notInAnnotation
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Parenthesized',
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),	
		
		initialNode : UML!InitialNode(
			inStructuredNode <- t
		),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToStatement',
			inStructuredNode <- t,
			source <- initialNode,
			target <- 	s.expression.getStatement.getSourceTargetOrOwnerSAN,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		finalControlFlow: UML!ControlFlow(
			name <- 'fromStatementToFinalNode',
			inStructuredNode <- t,
			source <- 	s.expression.getStatement.getSourceTargetOrOwnerSAN,
			target <- final,
			guard <- gu,
			weight <- we
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

abstract rule operatorexpression {
	from
		ioe	:	JAVA!Expression(
			ioe.notInClassInstanceCreation --MODIF	
		)
	to
		cb	:	UML!CallBehaviorAction(
			behavior <- ioe.getBehavior,
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- Sequence{inputPinOperand},
			result <- op
		),		
		inputPinOperand : UML!InputPin (
			name <- 'objectInput',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromOperandToCallBehaviorInput',
			source <- thisModule.resolveTemp(ioe.operand, 'op'),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPinOperand,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule postfixOperatorExpression extends operatorexpression{
	from
		ioe	:	JAVA!PostfixExpression  (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
				and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
				and ioe.notInClassInstanceCreation --MODIF
		)
	to
		cb	:	UML!CallBehaviorAction()	
}

rule prefixOperatorExpression extends operatorexpression{
	from
		ioe	:	JAVA!PrefixExpression  (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)	
				and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
				and ioe.notInClassInstanceCreation --MODIF
		)
	to
		cb	:	UML!CallBehaviorAction()
}

rule infixOperatorExpression {
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'==','!='}->excludes(ioe.operator.toString()))  
										and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))	
										and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation
										and ioe.notInClassInstanceCreation --MODIF	
										)	
		)
	to
		cb	:	UML!CallBehaviorAction(	
			behavior <- ioe.getBehavior,
			name <- ioe.operator.toString(),
--			name <- if (ioe.operator.toString() = '&&') then --to avoid serialization problem. &amp;&amp; was converted to &&
--							''
--						else 	
--							ioe.operator.toString()
--						endif,	
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- Sequence{inputPinFirstLeft, inputPinSecondRight},
			result <- op
		),
		
		inputPinFirstLeft : UML!InputPin (
			name <- 'first',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToCallBehaviorAction',
			source <- thisModule.resolveTemp(ioe.leftOperand, 'op'),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPinFirstLeft,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		inputPinSecondRight	: UML!InputPin (
			name <- 'second',
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToCallBehaviorAction',
			source <- thisModule.resolveTemp(ioe.rightOperand, 'op'),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPinSecondRight,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)		
}

rule equalOperatorExpression{
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'=='}->includes(ioe.operator.toString())) 
			and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))	
			and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
			and ioe.notInClassInstanceCreation --MODIF
		)
	to
		ti	:	UML!TestIdentityAction(
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement.getSourceTargetOrOwnerSAN,
			activity <- ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			first <- ipl,
			second <- ipr,
			result <- op
		),
		ipl	:	UML!InputPin (
			incoming <- of1,
			name <- 'first',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToTestIdentityAction',
			source <- 	if (ioe.leftOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'apn')
						else 	
							ioe.leftOperand.getStatement.getSourceTargetOrOwnerSAN
						endif,	
			target <- ipl,
			activity <- ioe.getOwningMethod,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		ipr	:	UML!InputPin (
			incoming <- of2,
			name <- 'second',
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToTestIdentityAction',
			source <- 	if (ioe.rightOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'apn')
						else 
							ioe.rightOperand.getStatement.getSourceTargetOrOwnerSAN
						endif,	
			target <- ipr,
			activity <- ioe.getOwningMethod,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		op	:	UML!OutputPin (
			name <- 'resultTestIdentityActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule notEqualOperatorExpression {
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'!='}->includes(ioe.operator.toString())) 
			and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
			and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)
			and ioe.notInClassInstanceCreation --MODIF
		)
	to
		cb	:	UML!TestIdentityAction(
			name <- ioe.operator.toString(),
			inStructuredNode <-if (ioe.refImmediateComposite().isInMethodOrConstructor) then
									ioe.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN
								else
									ioe.getStatement.getSourceTargetOrOwnerSAN
								endif,	
			activity <- if (ioe.refImmediateComposite().isInMethodOrConstructor) then
							ioe.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
						else
							ioe.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
						endif,
			first <- ipl,
			second <- ipr,
			result <- op
		),
		
		ipl	:	UML!InputPin (
			incoming <- of1,
			name <- 'first',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToTestIdentityAction',
			source <- 	if (ioe.leftOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'apn')
						else 	
							ioe.leftOperand.getStatement.getSourceTargetOrOwnerSAN
						endif,		
			target <- ipl,
			activity <- ioe.getOwningMethod,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		ipr	:	UML!InputPin (
			incoming <- of2,
			name <- 'second',
			upperBound <- li2
		),
		li2	:	UML!LiteralInteger(
			value <- 1
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToTestIdentityAction',
			source <- 	if (ioe.rightOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'apn')
					  	else 
							ioe.rightOperand.getStatement.getSourceTargetOrOwnerSAN
						endif,	
			target <- ipr,
			activity <- ioe.getOwningMethod,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		op	:	UML!OutputPin (
			name <- 'resultTestIdentityActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}


rule typeCastExpression {
	from 
		tce	:	JAVA!CastExpression (not tce.type.type.oclIsKindOf(JAVA!PrimitiveType)
			and (tce.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
			and (tce.notInInitializerOrFieldOrEnum and tce.notInAnnotation)
			and tce.notInClassInstanceCreation --MODIF
		)
	to
		t :	UML!StructuredActivityNode (
			name <- 'cast to '+tce.type.type.name,
			inStructuredNode <- if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			edge <- of2,
			structuredNodeInput <- Sequence{inputPin},
			structuredNodeOutput <-  op
		),
		
		inputPin : UML!InputPin (
			name <- 'structuredNodeInput',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of	:	UML!ObjectFlow (
			name <- 'fromActivityNodeToPrecedingStructuredActivityNode',
			source <- 	tce,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,	
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- inputPin,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		cf	:	UML!ControlFlow (
			name <- 'fromActivityNodeToStructuredActivityNode',
			source <- tce,
			target <- t,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		),
		of2	:	UML!ObjectFlow (
			name <- 'InternalStructuredActivityNodeObjectFlow',
			source <- inputPin,
			target <- op,
			guard <- gu3,
			weight <- we3
		),
		gu3	:	UML!LiteralBoolean(
			value <- false
		),
		we3	:	UML!LiteralBoolean(
			value <- false
		),
		op	:	UML!OutputPin (
			name <- 'internalStructuredActivityNodeOutput',
			type <- if (not tce.type.type.oclIsKindOf(JAVA!ArrayType))then
						tce.type.type.excludeUnresolvedTypeDec
					else 
						tce.type.type.elementType.type.excludeUnresolvedTypeDec 
					endif,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule numericCastExpression {
	from 
		tce	:	JAVA!CastExpression (
				tce.isANumericCast
				and (tce.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
				and (tce.notInInitializerOrFieldOrEnum and tce.notInAnnotation)
				and tce.notInClassInstanceCreation --MODIF
		)
	to
		san :	UML!CallBehaviorAction (
			name <- 'to '+tce.type.type.name,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			argument <- Sequence{ip},
			result <- op
		),
		
		ip	:	UML!InputPin (
			name <- 'CallBehaviorActionInput',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of	:	UML!ObjectFlow (
			name <- 'fromExpressionOutputToCallBehaviorAction',
			source <- thisModule.resolveTemp(tce.expression, 'op'),
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			target <- ip,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorActionOutput',
			type <- tce.type.type.excludeUnresolvedTypeDec,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule instanceOf {
	from 
		tce	:	JAVA!InstanceofExpression(	tce.notInInitializerOrFieldOrEnum 
											and tce.notInAnnotation
											and tce.notInClassInstanceCreation --MODIF
									)
	to
		san :	UML!ReadIsClassifiedObjectAction (
			name <- 'instanceOf ' + tce.rightOperand.type.name,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement.refImmediateComposite().getSourceTargetOrOwnerSAN
								endif,
			activity <- tce.getStatement.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			object <- ip,
			result <- op,
			classifier <- tce.getInstanciedClass
		)
		,
		
		ip	:	UML!InputPin (
			name <- 'instanceOf ' + tce.rightOperand.type.name + '_object',
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		op : UML!OutputPin (
			name <- 'instanceOf ' + tce.rightOperand.type.name + '_result',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
	do{
		thisModule.resolveTemp(tce.getOwningMethod, 'ob').name
			<- 	if not thisModule.resolveTemp(tce.getOwningMethod, 'ob').oclIsUndefined() then
					'fromParametersToReadIsClassifiedObjectAction'
				else OclUndefined endif;
		thisModule.resolveTemp(tce.getOwningMethod, 'ob').name
			<- 	if not thisModule.resolveTemp(tce.getOwningMethod, 'ob').oclIsUndefined() then
					'fromReadIsClassifiedObjectActionToActivityParameterNode'
				else OclUndefined endif;
	}	
}

rule unresolvedItemAccess {
	from
		s	:	JAVA!UnresolvedItemAccess(
			not s.getStatement.oclIsUndefined()	
			and s.notInClassInstanceCreation --MODIF
		)
	to
		t	:	UML!OpaqueAction(
			name <- 'UnresolvedItemAccess_'+s.element.name,
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		)
}

rule unresolvedAnnotationDeclaration{
	from
		s	:	JAVA!UnresolvedAnnotationDeclaration(
				s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule wildCardType{
	from
		s	:	JAVA!WildCardType(
				s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule PrimitiveType {
	from
		s	:	JAVA!PrimitiveType(
				s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!PrimitiveType(
			name <- s.name	
		)
}

rule annotationTypeDeclaration{
	from
		s	:	JAVA!AnnotationTypeDeclaration(
				s.notInClassInstanceCreation --MODIF	
		)
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule stringLiteral2ValueSpecification {
	from
		sl	:	JAVA!StringLiteral (if (sl.notInAnnotation) then 
									sl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
									else false endif
									and sl.notInClassInstanceCreation --MODIF
		)
	to
		vsa	:	UML!ValueSpecificationAction (
			result <- op,
			value <- vs,
			inStructuredNode <- sl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- sl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralString(
			value <- sl.escapedValue.regexReplaceAll('"', '')
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule charLiteral2ValueSpecification {
	from
		cl	:	JAVA!CharacterLiteral ( if (cl.notInAnnotation) then 
										cl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
										else false endif
										and cl.notInClassInstanceCreation --MODIF
			)
	to
		vsa	:	UML!ValueSpecificationAction (
			result <- op,
			value <- vs,
			inStructuredNode <- cl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- cl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralString(
			value <- cl.escapedValue.regexReplaceAll('"', '')
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule Booleanliteral2ValueSpecification {
	from
		bl	:	JAVA!BooleanLiteral (
			bl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
			and bl.notInAnnotation
			and bl.notInClassInstanceCreation --MODIF
		)
	to
		vsa	:	UML!ValueSpecificationAction (
			result <- op,
			value <- vs,
			inStructuredNode <- bl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- bl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralBoolean(
			value <- bl.value
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule numberLiteral2ValueSpecification {
	from
		nl	:	JAVA!NumberLiteral (
			(nl.tokenValue.indexOf('.')=-1) 
			and nl.notInInitializerOrFieldOrEnum				
			and nl.notInAnnotation
			and nl.notInClassInstanceCreation --MODIF
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-vs,
			inStructuredNode <- nl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- nl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralInteger(
			value <- nl.tokenValue.regexReplaceAll('[A-Za-z]', '').toInteger()
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule realNumberLiteral2ValueSpecification {
	from
		nl	:	JAVA!NumberLiteral (
			(not (nl.tokenValue.indexOf('.')=-1)  
			and	nl.notInInitializerOrFieldOrEnum)
			and nl.notInAnnotation
			and nl.notInClassInstanceCreation --MODIF
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-vs,
			inStructuredNode <- nl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- nl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		vs	:	UML!LiteralReal(
			value <- nl.tokenValue.regexReplaceAll('[A-Za-z]', '').toReal()
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

rule nullLiteral2ValueSpecification {
	from
		nl	:	JAVA!NullLiteral (
			nl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
			and not nl.refImmediateComposite().oclIsKindOf(JAVA!MethodInvocation)
			and nl.notInAnnotation
			and nl.notInClassInstanceCreation --MODIF
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-OclUndefined,
			inStructuredNode <- nl.getStatement.getSourceTargetOrOwnerSAN,
			activity <- nl.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput',
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

---Lazy rules
unique lazy rule createArgumentNotPrimitiv {
	from
		a	:	JAVA!Expression
	to
		inputPin : UML!InputPin (
			name <- 'objectInput',
			incoming <- of2,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromExpressionOutput',
			source <- thisModule.resolveTemp(a, 'op'),
			--MODIF
			activity <- a.getOwningMethod,
--			activity <- if a.refImmediateComposite().method.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)then
--							if  a.refImmediateComposite().method.getCorrespondingDec.oclIsTypeOf(JAVA!MethodDeclaration)then
--								a.refImmediateComposite().method.getCorrespondingDec
--							else a.refImmediateComposite().method									
--							endif
--						else a.getOwningMethod						
--						endif 
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		cf	:	UML!ControlFlow (
			name <- 'fromExpressionOutputToStatement',
			source <- thisModule.resolveTemp(a, 'op'),
			--MODIF
			activity <- a.getOwningMethod,
--			activity <- if a.refImmediateComposite().method.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)then
--							if  not a.refImmediateComposite().method.getCorrespondingDec.oclIsTypeOf(JAVA!MethodDeclaration)then
--								a.refImmediateComposite().method
--							else a.refImmediateComposite().method.getCorrespondingDec endif
--						else a.getOwningMethod endif,
			target <- 	if (a.refImmediateComposite().getStatement.oclIsKindOf(JAVA!ReturnStatement))then
							if (not a.refImmediateComposite().getStatement.isReturnStateGeneratingObjectFlow)then
								thisModule.resolveTemp(a.refImmediateComposite().getStatement, 'co')
							else OclUndefined endif	
						else a.refImmediateComposite() endif,
			guard <- gu2,
			weight <- we2
		),
		gu2	:	UML!LiteralBoolean(
			value <- false
		),
		we2	:	UML!LiteralBoolean(
			value <- false
		)
}

unique lazy rule createArgument {
	from
		a	:	JAVA!Expression
	to
		inputPin : UML!InputPin (
			name <- 'objectInput',
			incoming <- of2,
			upperBound <- li
		),
		li	:	UML!LiteralInteger(
			value <- 1
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromExpressionOutputToStatement',
			source <- thisModule.resolveTemp(a, 'op'),
			inStructuredNode <- a.getStatement.getSourceTargetOrOwnerSAN,
			activity <- a.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
}

unique lazy rule Parameters2ActivityParameter{
	from
		param	:	JAVA!SingleVariableDeclaration 
	to	
		paramAct	:	UML!Parameter(
			name <- param.name,
			type <-	if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec
						endif
					endif
		)
}


rule arrayToClass {
	from
		arrayType	:	JAVA!ArrayType(
				arrayType.notInClassInstanceCreation --MODIF	
		)
	to
		umlClass	:	UML!Class(
			name <- arrayType.elementType.type.name+'[]',
			ownedAttribute <- umlProperty			
		), 
		umlProperty	:	UML!Property(
			type <- if (arrayType.elementType.type.oclIsKindOf(JAVA!TypeParameter)) then
							arrayType.elementType.type.excludeUnresolvedTypeDec
					else 
						arrayType.elementType.type.excludeUnresolvedTypeDec
					endif,
			name <- 'type'		
		)
}

rule typeParameterToClass {
	from 
		jBodyDec : JAVA!TypeParameter(
				jBodyDec.notInClassInstanceCreation --MODIF	
		)
	to 
		umlElement : UML!Class( 
				name <- jBodyDec.name
		)
}

unique lazy rule createEmptyElse{
	from
		ifs	:	JAVA!IfStatement
	to
		t : UML!StructuredActivityNode(
			inStructuredNode <- ifs,
			name <- 'Empty Else'
		)
}

unique lazy rule createListGetFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		listGet : UML!OpaqueBehavior(
			name <- 'ListGet',
			ownedParameter <- Sequence{list, index, result}
		),
		list : UML!Parameter(
			name <- 'list'	
		),
		index : UML!Parameter(
			name <- 'index'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(listGet);
	}	
}

unique lazy rule createIntegerMinusFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerMinus : UML!OpaqueBehavior(
			name <- 'IntegerMinus',
			ownedParameter <- Sequence{x, y, result}			
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerMinus);
	}	
}

unique lazy rule createIntegerPlusFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerPlus : UML!OpaqueBehavior(
			name <- 'IntegerPlus',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerPlus);
	}
}

unique lazy rule createIntegerTimesFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerTimes : UML!OpaqueBehavior(
			name <- 'IntegerTimes',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerTimes);
	}	
}

unique lazy rule createIntegerDivideFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerDivide : UML!OpaqueBehavior(
			name <- 'IntegerDivide',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerDivide);
	}	
}

unique lazy rule createIntegerLessFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerLess : UML!OpaqueBehavior(
			name <- 'IntegerLess',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerLess);
	}
}

unique lazy rule createIntegerGreaterFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerGreater : UML!OpaqueBehavior(
			name <- 'IntegerGreater',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerGreater);
	}
}

unique lazy rule createIntegerLessOrEqualsFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerLessOrEquals : UML!OpaqueBehavior(
			name <- 'IntegerLessOrEquals',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerLessOrEquals);
	}	
}

unique lazy rule createIntegerGreaterOrEqualsFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerGreaterOrEquals : UML!OpaqueBehavior(
			name <- 'IntegerGreaterOrEquals',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerGreaterOrEquals);
	}
}


unique lazy rule createObjectFlowToVSA{
	from
		s	:	JAVA!ExpressionStatement
	to
		valueSpecActionOF : UML!ObjectFlow(
			name <- 'objectFlowFromValueSpecificationAction',
			source <- valueSpecAction,
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		),
		valueSpecAction	: UML!ValueSpecificationAction(
			value <- literUnlimNatur,
			inStructuredNode <- s.refImmediateComposite().getSourceTargetOrOwnerSAN,
			activity <- s.refImmediateComposite().getOwningMethodOnEmptySourceTargetOrOwnerSAN
		),
		literUnlimNatur : UML!LiteralUnlimitedNatural(
			value <- -1
		)
}

unique lazy rule createObjectFlowToNode{
	from
		s	:	JAVA!ExpressionStatement
	to
		insertAtOF : UML!ObjectFlow(
			name <- 'objectFlowFromNode',
			source <- 	s.expression.arguments 
							-> reject(arg | arg.isALiteral)
							-> select(arg | arg.getVarAccessExpression.name = 'insertAt')
							-> collect(arg | arg.getVarAccessExpression)
							-> flatten()
							-> first(),
			inStructuredNode <- s.getStatement.getSourceTargetOrOwnerSAN,
			activity <- s.getStatement.getOwningMethodOnEmptySourceTargetOrOwnerSAN,
			guard <- gu,
			weight <- we
		),
		gu	:	UML!LiteralBoolean(
			value <- false
		),
		we	:	UML!LiteralBoolean(
			value <- false
		)
}

rule fieldDeclarationToProperty{
	from
		fieldDec : JAVA!FieldDeclaration(
				fieldDec.notInClassInstanceCreation --MODIF	
		)
	to
		struct : UML!Property(
			name <- fieldDec.getFieldName,
			type <- if (fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
							fieldDec.getFieldType
					else if (fieldDec.getFieldType.oclIsKindOf(JAVA!TypeParameter)) then
								fieldDec.getFieldType
						 else 
						 	if (fieldDec.getFieldType.oclIsKindOf(JAVA!ParameterizedType)) then
								fieldDec.getFieldType.typeArguments ->first().type.excludeUnresolvedTypeDec
							else fieldDec.getFieldType endif	
						 endif
					endif,
			lower <- if (fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
						1
					else 0 endif,
			upper <- if (fieldDec.isAList or fieldDec.isASet)then
						if fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType) then
							-1
						else 1 endif
					else 1	endif,
			isUnique <-  fieldDec.isASet,
			isOrdered <- fieldDec.isAList or fieldDec.getFieldType.oclIsKindOf(JAVA!ArrayType),
			visibility <- fieldDec.getFieldVisibility
							
		)
	do{
		if (not thisModule.resolveTemp(fieldDec.getInstanciedClass, 't').oclIsUndefined())then
			thisModule.resolveTemp(fieldDec.getInstanciedClass, 't').refSetValue('ownedAttribute', struct)
		else OclUndefined endif;
	}	
}

unique lazy rule createProperty{
	from
		singleAccess : JAVA!ASTNode
	to
		struct : UML!Property(
			name <- if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
						singleAccess.getFieldName
					else	
						if (singleAccess.oclIsKindOf(JAVA!InfixExpression)) then
							if (singleAccess.leftOperand.oclIsKindOf(JAVA!UnresolvedItemAccess)) then
								singleAccess.leftOperand.element.name
							else singleAccess.leftOperand.name endif
						else
							if (not singleAccess.isALiteral and not singleAccess.oclIsKindOf(JAVA!TypeAccess))then
								singleAccess.variable.name
							else 
								if (singleAccess.type.oclIsKindOf(JAVA!ClassDeclaration))then
									singleAccess.type.name
								else							
									singleAccess.type.type.name 
								endif
							endif	
						endif
					endif,
			type <- if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
						if (singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
									singleAccess.getFieldType
							else if (singleAccess.getFieldType.oclIsKindOf(JAVA!TypeParameter)) then
										singleAccess.getFieldType
								 else 
								 	if (singleAccess.getFieldType.oclIsKindOf(JAVA!ParameterizedType)) then
										singleAccess.getFieldType.typeArguments ->first().type.excludeUnresolvedTypeDec
									else singleAccess.getFieldType endif	
								 endif
							endif
					else	
						if (singleAccess.getVariableType.oclIsKindOf(JAVA!ParameterizedType)) then 
							singleAccess.getVariableType.typeArguments -> first().type.excludeUnresolvedTypeDec
						else 
							if (singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)) then
								singleAccess.getVariableType.elementType.type.excludeUnresolvedTypeDec
							else
								singleAccess.getVariableType.excludeUnresolvedTypeDec
							endif	
						endif
					endif,
			lower <-if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
						if (singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
							1
						else 0 endif
					else
						if (singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)) then
							1
						else 0 endif
					endif,
			upper <- if (singleAccess.isAList or singleAccess.isASet)then
						if singleAccess.oclIsKindOf(JAVA!FieldDeclaration)then
							if singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType) then
								-1
							else 1 endif
						else
							if singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType) then
								-1
							else 1 endif
						endif
					else 1	endif,
			isUnique <-  singleAccess.isASet,
			isOrdered <- singleAccess.isAList or 
							(
								if singleAccess.oclIsKindOf(JAVA!FieldDeclaration)then
									singleAccess.getFieldType.oclIsKindOf(JAVA!ArrayType)
								else 
									singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)
								endif
							),
			visibility <- 	if (singleAccess.oclIsKindOf(JAVA!FieldDeclaration))then
								singleAccess.getFieldVisibility
							else
								if (not singleAccess.isALiteral and not singleAccess.oclIsKindOf(JAVA!TypeAccess)
									and not singleAccess.oclIsKindOf(JAVA!InfixExpression))then
									if (singleAccess.variable.oclIsKindOf(JAVA!VariableDeclarationFragment))then
										if (singleAccess.variable.variablesContainer.oclIsKindOf(JAVA!FieldDeclaration))then
											singleAccess.variable.variablesContainer.getFieldVisibility
										else OclUndefined endif		
									else OclUndefined endif	
								else 								
									if (singleAccess.oclIsKindOf(JAVA!InfixExpression)) then
										if (singleAccess.leftOperand.oclIsKindOf(JAVA!MethodInvocation)) then
											if (singleAccess.leftOperand.method.oclIsKindOf(JAVA!MethodDeclaration)) then
												singleAccess.leftOperand.method.modifier.visibility
											else #package endif
										else
											if (singleAccess.leftOperand.oclIsKindOf(JAVA!UnresolvedItemAccess)) then
												#package
											else 
												singleAccess.leftOperand.type.modifier.visibility 
											endif
										endif	
									else
										if (singleAccess.oclIsKindOf(JAVA!TypeAccess) 
											and singleAccess.type.oclIsKindOf(JAVA!ClassDeclaration))then
											singleAccess.type.modifier.visibility
										else
											singleAccess.type.type.modifier.visibility
										endif
									endif
								endif
							endif
		)
	do{
		thisModule.allASTNode <- thisModule.allASTNode -> including(singleAccess, struct);
		if (not thisModule.resolveTemp(singleAccess.getInstanciedClass, 't').oclIsUndefined())then
			thisModule.resolveTemp(singleAccess.getInstanciedClass, 't').refSetValue('ownedAttribute', struct)
		else OclUndefined endif;
	}	
}

unique lazy rule createOutputPin{
	from
		s	:	JAVA!ExpressionStatement, outputPinName : String
	to
		op : UML!OutputPin (
			name <- outputPinName,
			upperBound <- up
		),
		up	:	UML!LiteralInteger(
			value <- 1
		)
}

unique lazy rule createStructuredActivityNode{
	from
		otherT :	UML!StructuredActivityNode, sanName : String
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- otherT,
			name <- sanName
		)
}

unique lazy rule createActivityFinalNode {
	from
		t : UML!StructuredActivityNode
	to
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

--***************Unresolved items***************
rule JUnresolvedItemToUmlClass {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and
			(
				jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!ClassDeclaration)
				or
				jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!ImportDeclaration)
			)
			and jUnresItem.notInClassInstanceCreation --MODIF
		)
	to 
		umlNamedElement : UML!Class(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot)
		)
}

rule JUnresolvedItemToUmlInterface {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and (jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!InterfaceDeclaration))
			and jUnresItem.notInClassInstanceCreation --MODIF
		)
	to 
		umlNamedElement : UML!Interface(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot) 
		)
}

rule JUnresolvedItemToUmlEnum {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and (jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!EnumDeclaration))
			and jUnresItem.notInClassInstanceCreation --MODIF
		)
	to 
		umlNamedElement : UML!Enumeration(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot)
		)
}
--MODIF: commented
--rule JUnresolvedMethodDecToActivity{
--	from 
--		construcOrMethodDec : JAVA!UnresolvedMethodDeclaration(
--			not construcOrMethodDec.getCorrespondingDec.oclIsKindOf(JAVA!MethodDeclaration)
--			and construcOrMethodDec.notInClassInstanceCreation --MODIF
--		)
--	to 
--		act	:	UML!Activity(
--			--name <- construcOrMethodDec.name,
--			name <- '5457'.concat(construcOrMethodDec.name),
--			visibility <- construcOrMethodDec.getAbsMethDecVisibility
--		),
--		
--		init	:	UML!InitialNode(
--			activity <- act
--		),
--		icf : UML!ControlFlow(
--			name <- 'fromIntialNodeToOpaqueAction',
--			activity <- act,
--			target <- opaqueAction,
--			source <- init 
--		),
--		
--		opaqueAction : UML!OpaqueAction(
--			name <- 'OpaqueAction_UnresolvedMethodDelaration',
--			activity <- act
--		),
--		
--		final	:	UML!ActivityFinalNode(
--			activity <- act
--		),
--		fcf : UML!ControlFlow(
--			name <- 'fromOpaqueActionToFinalNode',
--			activity <- act,
--			target <- final,
--			source <- opaqueAction
--		)
--		
--}
